## å‰è¨€

ç ç‡æ§åˆ¶æ¨¡å—æ˜¯ç¼–ç å™¨å†…éƒ¨å¾ˆé‡è¦çš„ä¸€ä¸ªæ¨¡å—ã€‚åœ¨x264ä¸­ç ç‡æ§åˆ¶åˆ†ä¸º**å¸§çº§ç æ§**å’Œ**è¡Œçº§ç æ§**(*x264ä¸­è¿˜æœ‰ä¸€äº›åŠŸèƒ½ä¼šå½±å“åˆ°å®å—çš„QPï¼Œä¾‹å¦‚AQã€MB-Treeã€RDOç­‰ï¼Œä½†ä¸¥æ ¼ä¸Šè®²è¿™äº›ä¸å±äºç ç‡æ§åˆ¶éƒ¨åˆ†çš„åŠŸèƒ½ï¼Œå› ä¸ºå®ƒä»¬å¹¶æ²¡æœ‰èµ·åˆ°ä¸€ä¸ªâ€œæ§â€çš„ä½œç”¨*)ï¼Œåˆ†ä¸ºä¸¤ä¸ªç« èŠ‚è¿›è¡Œä»‹ç»ï¼Œæœ¬ç« èŠ‚ä¸»è¦ä»‹ç»çš„**x264çš„å¸§çº§ç æ§**



## ç æ§æ–¹å¼

x264æ˜¾ç¤ºæä¾›ä¸‰ç§ç ç‡æ§åˆ¶çš„æ–¹æ³•ï¼š**CQPã€CRFã€ABR**

- CQPå›ºå®šQPçš„æ„æ€ï¼Œå³ä½¿ç”¨å›ºå®šçš„å¸§çº§QPè¿›è¡Œé‡åŒ–ã€‚CQPç æ§ä¸»è¦æ˜¯ä¸ºäº†ä¿è¯ç¼–ç è´¨é‡ï¼Œå¹¶ä¸careç¼–ç ç ç‡
- CRFï¼Œå›ºå®šç ç‡å› å­ï¼Œæ˜¯x264é»˜è®¤çš„ç æ§æ–¹å¼ï¼ŒCRFä¼šæ ¹æ®å½“å‰å›¾åƒçš„å¤æ‚åº¦åŠ¨æ€è°ƒèŠ‚å¸§çº§QPï¼ŒåŒç­‰ç ç‡ä¸‹CRFçš„ç¼–ç è´¨é‡ä¼šæ¯”CQPæ›´é«˜ã€‚ ä¸CQPç±»ä¼¼ï¼ŒCRFä¸»è¦ä¹Ÿæ˜¯ä¿è¯ç¼–ç è´¨é‡ï¼Œéƒ½ç”±äºå…¶ä¼šåŠ¨æ€è°ƒèŠ‚QPçš„ç‰¹æ€§ï¼Œæ‰€ä»¥ä¹Ÿä¼šç¨å¾®å…¼é¡¾ç¼–ç ç ç‡
- ABRï¼Œå¹³å‡ç¼–ç ç ç‡ï¼Œå³è®©å®é™…çš„ç¼–ç ç ç‡èƒ½å¤Ÿæ»¡è¶³æœŸæœ›çš„ç¼–ç ç ç‡ï¼Œæ­¤ç æ§æ–¹å¼ä¼šæ›´åé‡ä¿è¯ç ç‡ï¼Œå½“ç„¶è¿™ä¹Ÿä¼šç‰ºç‰²ä¸€å®šçš„ç¼–ç è´¨é‡

ç”±äºCQPçš„æ–¹å¼æ¯”è¾ƒç®€å•ï¼Œé™¤äº†å®éªŒç ”ç©¶å¤–å®é™…ä½¿ç”¨å¾—å¹¶ä¸å¤šï¼Œæ‰€ä»¥æœ¬ç« èŠ‚å°±ä¸å¯¹å…¶è¿›è¡Œè¿‡å¤šä»‹ç»(åœ¨ä¸‹æ–‡çš„<u>æºç è§£æ</u>éƒ¨åˆ†ä¼šç¨å¾®è¯´ä¸€ä¸‹)ï¼Œæ‰€ä»¥**æœ¬ç« èŠ‚ä¸»è¦ä»‹ç»CRFã€ABRä¸¤ç§ç æ§æ–¹å¼**



## ç æ§åŸç†åˆ†æ

#### åŸºæœ¬å…¬å¼

- qscale = 0.85 * 2^((QP - 12)  / 6)
- QP = 12 + 6 * log2(qscale/0.85)
- QStep = 2^((QP - 4)/6)
- QP = 6 * log2(QStep) + 4

ç”±ä¸Šè¿°å¯ä»¥çœ‹å‡ºqscaleä¸QPå‘ˆæ­£ç›¸å…³ï¼ŒQPä¸QStepå‘ˆæ­£ç›¸å…³



#### æ¡ä»¶å‡è®¾

å‡è®¾å½“å‰å›¾åƒå®é™…çš„ç¼–ç æ¯”ç‰¹æ•°ä¸ºbitsï¼Œå½“å‰å›¾åƒçš„å¤æ‚åº¦ä¸ºcomplexityï¼Œå½“å‰çš„é‡åŒ–ç­‰çº§ä¸ºqscale

å½“é‡åŒ–ç­‰çº§qscaleä¸å˜æ—¶ï¼Œcomplexityè¶Šå¤§ï¼Œbitsè¶Šå¤§

å½“complexityä¸å˜ï¼Œqscaleè¶Šå¤§ï¼Œbitsè¶Šå°

å› æ­¤æˆ‘ä»¬å¯ä»¥å¾—åˆ°ä¸€æ¡ç»“è®ºï¼š**å®é™…ç¼–ç æ¯”ç‰¹æ•°ä¸å¤æ‚åº¦æˆæ­£æ¯”ï¼Œä¸qscaleæˆåæ¯”**

x264çš„ç ç‡æ§åˆ¶å°±æ˜¯åŸºäºä¸Šè¿°è¿™æ¡ç»“è®º(*è™½ç„¶ä¸æ˜¯å¾ˆå‡†ç¡®ï¼Œä¸­é—´çš„å½±å“å› ç´ ä¼šæ¯”è¾ƒå¤šï¼Œä½†æ˜¯æˆ‘ä»¬å§‘ä¸”è®¤ä¸ºå°±æ˜¯è¿™æ ·å§*)

------



x264 ä¸­ï¼Œé¦–å…ˆæ ¹æ®æ¯å¸§çš„å¤æ‚åº¦ï¼Œåœ¨å¸§ä¸å¸§ä¹‹é—´åˆ†é…ç ç‡æ¯”ä¾‹ã€‚ç„¶åæ ¹æ®ç ç‡é¢„ç®—ï¼Œå°†æ¯å¸§ç¼©æ”¾åˆ°åˆé€‚å¤§å°ã€‚è¿™ä¸ªç¼©æ”¾ç³»æ•°ç§°ä¸º ratefactor ã€‚

ç„¶å **qscale = f(complexity) / ratefactor** 

æ‰€è°“ crf (constant ratefactor) æ¨¡å¼ï¼Œå°±æ˜¯å›ºå®šratefactor å‚æ•°ï¼Œ ç ç‡åˆ†é…ç”±å¤æ‚åº¦å†³å®šã€‚
è€Œabræ¨¡å¼ï¼Œä¼šæ ¹æ®å½“å‰çš„å®é™…ç¼–ç ç ç‡ä¸ç›®æ ‡ç¼–ç ç ç‡çš„åå·®æƒ…å†µåŠ¨æ€è°ƒèŠ‚ratefactorï¼Œä»è€Œä¿è¯ç¼–ç ç ç‡çš„ç¨³å®šã€‚

ç›¸åŒf(complexity)ä¸‹ï¼Œratefactorè¶Šå°ï¼Œqscaleè¶Šå¤§ï¼Œç¼–ç è´¨é‡è¶Šä½ï¼›åä¹‹åˆ™è¶Šé«˜

æ³¨æ„**qscale = f(complexity) / ratefactor** è¿™æ¡å…¬å¼ï¼Œcomplexityä¼šç»è¿‡f()è¿ç®—ï¼Œæ­¤f()å‡½æ•°å°±æ˜¯**æ„ŸçŸ¥ç¼–ç ä¼˜åŒ–å‡½æ•°**



**ä»€ä¹ˆæ˜¯æ„ŸçŸ¥ç¼–ç ä¼˜åŒ–ï¼Ÿ**

é¦–å…ˆæˆ‘ä»¬å…ˆæŠ›å‡ºä¸€ä¸ªé—®é¢˜ï¼Œâ€œå‡è®¾å¸§açš„å¤æ‚åº¦ä¸ºXï¼Œè®¡ç®—å¾—åˆ°çš„qscaleä¸ºYï¼Œå¸§bçš„å¤æ‚åº¦ä¸º2*Xï¼Œå¦‚æœæ²¡æœ‰æ„ŸçŸ¥ç¼–ç ä¼˜åŒ–çš„è¯è®¡ç®—å¾—åˆ°çš„qscaleä¸º2Yï¼Œæ­¤æ—¶ä»¥2Yçš„qscaleå¯¹å¸§bè¿›è¡Œç¼–ç èƒ½å¦ä¿è¯å¸§bçš„è´¨é‡è·Ÿå¸§açš„è´¨é‡å·®è·ï¼Ÿâ€ï¼Œç­”æ¡ˆæ˜¯ä¸èƒ½ä¿è¯ä¸¤è€…çš„è´¨é‡å·®è·ï¼Œå°±æ˜¯ç”±äºâ€œå¤æ‚åº¦ä¸qscaleçº¿æ€§å…³ç³»â€çš„å¼Šç«¯ï¼Œx264å¼•å…¥äº†æ„ŸçŸ¥ç¼–ç ä¼˜åŒ–ï¼Œå¯¹complexityè¿›è¡Œ**éçº¿æ€§å¤„ç†**ï¼Œä»è€Œä¿è¯å³ä½¿æ˜¯é«˜complexityå¾—åˆ°çš„qscaleä¹Ÿä¸ä¼šä¸ä½complexityçš„qscaleç›¸å·®å¤ªå¤§ï¼Œè¿™å°±æ˜¯f()å‡½æ•°çš„ä½œç”¨ã€‚

**recq = f(complexity) = complexity^(1-qcomp)**   qcompâˆˆ[0,1] ï¼›  recqå°±æ˜¯å‹ç¼©åçš„å›¾åƒå¤æ‚åº¦ï¼Œæ˜¯ç ç‡åˆ†é…çš„ä¾æ®

å¯è§f()å°±æ˜¯ä¸ªæŒ‡æ•°å‡½æ•°ï¼Œqcompè¶Šå°ï¼Œcomplexityå¯¹qscaleå½±å“çš„æ¯”é‡å°±è¶Šå¤§ï¼Œåä¹‹åˆ™è¶Šå°

qcomp = 0æ—¶ï¼Œf(complexity) = complexityï¼Œåˆ™qscale ä¸å¤æ‚åº¦æˆæ­£æ¯”ï¼Œåˆ†é…ç»™å¹³ç¼“çš„å¸§å’Œå¤æ‚çš„å¸§çš„æ¯”ç‰¹æ˜¯ä¸€æ ·çš„

qcomp = 1æ—¶ï¼Œf(complexity) = 1ï¼Œ qscale ä¸å¤æ‚åº¦æ— å…³ï¼Œç›¸å½“äºå…³é—­äº†æ„ŸçŸ¥ç¼–ç ä¼˜åŒ–

------



**å¦‚ä½•çŸ¥é“å›¾åƒæ¨¡ç³Šå¤æ‚åº¦complexityï¼Ÿ**

è¿™é‡Œå…ˆçœ‹éƒ¨åˆ†x264çš„æºç 

```c++
rcc->last_satd = x264_rc_analyse_slice( h );
rcc->short_term_cplxsum *= 0.5;
rcc->short_term_cplxcount *= 0.5;
rcc->short_term_cplxsum += rcc->last_satd / (CLIP_DURATION(h->fenc->f_duration) / BASE_FRAME_DURATION);
rcc->short_term_cplxcount ++;

rce.tex_bits = rcc->last_satd;
rce.blurred_complexity = rcc->short_term_cplxsum / rcc->short_term_cplxcount;
```

*blurred_complexityçš„è®¡ç®—å…¬å¼å¦‚ä¸‹ï¼š*
$$
Blurcplx = \frac{Cplxsum}{Cplxcount}
$$
*short_term_cplxsumã€short_term_cplxcountçš„è®¡ç®—å…¬å¼å¦‚ä¸‹ï¼š*
$$
\begin{cases} Cplxsum[i] = {Cplxsum[i-1] * 0.5} + satd \\ Cplxcount[i] = {Cplxcount[i-1] * 0.5} + 1\end{cases}
$$
å…¶ä¸­satd = x264_rc_analyse_slice(h);  æ­¤å¤„å°±æ˜¯è·å–å½“å‰å¸§çš„ç¼–ç ä»£ä»·ä¿å­˜åˆ°satdä¸­ï¼Œæ­¤ä»£ä»·åœ¨å¸§ç±»å‹å†³ç­–çš„æ—¶å€™å·²ç»è®¡ç®—å¾—åˆ°äº†(è¯¦ç»†å¯å‚è€ƒ"å¸§ç±»å‹å†³ç­–&åœºæ™¯åˆ‡æ¢æ£€æµ‹"ç« èŠ‚)

ç”±ä¸Šè¿°ä¸¤ä¸ªå…¬å¼å¯ä»¥çœ‹å‡ºï¼Œ**å½“å‰å›¾åƒçš„æ¨¡ç³Šå¤æ‚åº¦ä¸å†å²å¸§çš„æ¨¡ç³Šå¤æ‚åº¦ä»¥åŠå½“å‰å¸§çš„satdæœ‰å…³**

------



**ratefactorç ç‡å› å­**

é€šè¿‡ä¸Šé¢çš„ä»‹ç»å·²ç»èƒ½å¤ŸçŸ¥é“å½“å‰å›¾åƒç»è¿‡æ„ŸçŸ¥ç¼–ç ä¼˜åŒ–åçš„å›¾åƒå¤æ‚åº¦äº†ï¼Œè®¡ç®—å½“å‰çš„qscaleè¿˜éœ€è¦ç¡®å®šratefactorã€‚

å¯¹äºCRFæ¨¡å¼ï¼Œratefactorçš„å€¼æ˜¯å›ºå®šçš„ï¼Œä»£ç å¦‚ä¸‹

```c++
if( h->param.rc.i_rc_method == X264_RC_CRF )
{
        /* Arbitrary rescaling to make CRF somewhat similar to QP.
         * Try to compensate for MB-tree's effects as well. */
        double base_cplx = h->mb.i_mb_count * (h->param.i_bframe ? 120 : 80);
        double mbtree_offset = h->param.rc.b_mb_tree ? (1.0-h->param.rc.f_qcompress)*13.5 : 0;
        rc->rate_factor_constant = pow( base_cplx, 1 - rc->qcompress )
                                 / qp2qscale( h->param.rc.f_rf_constant + mbtree_offset + QP_BD_OFFSET );
}

// ---------

if( h->param.rc.i_rc_method == X264_RC_CRF )
{
    // å‚æ•°äºŒä¸ºä¸Šæ–‡ä»‹ç»çš„ratefactor
    q = get_qscale( h, &rce, rcc->rate_factor_constant, h->fenc->i_frame );
}
```

è€Œå¯¹äºABRæ¨¡å¼ï¼Œä¼šæ ¹æ®å½“å‰æœŸæœ›ç¼–ç ç ç‡å’Œå®é™…ç ç‡çš„åå·®åŠ¨æ€è°ƒæ•´ratecontrolï¼Œè¿™é‡Œä¹Ÿç›´æ¥è´´ä»£ç çœ‹

```c++
if( h->param.rc.i_rc_method == X264_RC_CRF )
{
    q = get_qscale( h, &rce, rcc->rate_factor_constant, h->fenc->i_frame );
}
else
{
    // ABRæ¨¡å¼ï¼Œå‚æ•°äºŒä¸ºratefactor
    q = get_qscale( h, &rce, rcc->wanted_bits_window / rcc->cplxr_sum, h->fenc->i_frame );
}
```

ç”±ä»£ç å¯çŸ¥ï¼ŒABRæ¨¡å¼çš„**ratefactor = wanted_bits_window / cplxr_sum**

wanted_bits_window çš„åˆå§‹å€¼1.0 * rc->bitrate / rc->fpsï¼Œå³ç›®æ ‡ç ç‡/ç›®æ ‡å¸§ç‡ï¼Œå°±æ˜¯ç›®æ ‡å¹³å‡å•å¸§çš„æ¯”ç‰¹æ•°

cplxr_sumçš„åˆå§‹å€¼æ˜¯.01 * pow( 7.0e5, rc->qcompress ) * pow( h->mb.i_mb_count, 0.5 )ã€‚ qcompressæ˜¯ä¸Šæ–‡è¯´åˆ°çš„æ„ŸçŸ¥ç¼–ç ç³»æ•°ï¼Œi_mb_countæ˜¯å®å—æ€»æ•°é‡

wanted_bits_window å’Œ cplxr_sumåœ¨æ¯ä¸€å¸§ç¼–ç å®Œæˆä¹‹åéƒ½ä¼šè¿›è¡Œæ›´æ–°ï¼Œå…¬å¼å¦‚ä¸‹ï¼š

- wanted_bits_window = (wanted_bits_window +  f_duration * bitrate) * cbr_decayï¼›  // f_durationä¸ºå¸§ç‡çš„å€’æ•°ï¼Œbitrateä¸ºç›®æ ‡ç ç‡ï¼Œcbr_decayæ˜¯ä¸€ä¸ªè¡°å‡ç³»æ•°
- cplxr_sum = (cplxr_sum + bits * qscale / rceq) * cbr_decayï¼› // bitsä¸ºå®é™…çš„ç¼–ç æ¯”ç‰¹æ•°ï¼Œqscaleä¸ºå¹³å‡å®å—çš„qscaleï¼Œ recqä¸ºæ„ŸçŸ¥ç¼–ç ä¼˜åŒ–åçš„å›¾åƒå¤æ‚åº¦,  cbr_decayæ˜¯ä¸€ä¸ªè¡°å‡ç³»æ•°ä¸»è¦ä¸ºäº†é™ä½å†å²å¸§çš„å½±å“

ç”±ä¸Šè¿°ä¸¤ä¸ªå…¬å¼å¯ä»¥çœ‹å‡ºï¼Œwanted_bits_windowè¡¨ç¤ºæœŸæœ›å¢é•¿çš„æ¯”ç‰¹æ•°ï¼Œcplxt_sumè¡¨ç¤ºå®é™…å¢é•¿çš„æ¯”ç‰¹æ•°

å¦‚æœå½“å‰å¸§å®é™…ç¼–ç çš„æ¯”ç‰¹æ•°å¤§äºæœŸæœ›çš„æ¯”ç‰¹æ•°æ—¶ï¼Œé‚£ä¹ˆç¼–ç ç»“æŸæ›´æ–°cplxr_sumåçš„å€¼ä¼šæ›´å¤§ä¸€ç‚¹ï¼Œæ‰€ä»¥åœ¨ç¼–ç ä¸‹ä¸€å¸§è®¡ç®—ratefactor = wanted_bits_window / cplxr_sumæ—¶ï¼Œå¾—åˆ°çš„ratefactorä¼šæ›´å°ä¸€ç‚¹ï¼Œqscaleæ›´å¤§ï¼Œç¼–ç çš„æ¯”ç‰¹æ•°æ›´å°‘ä¸€ç‚¹ï¼Œä»è€Œå‡è¡¡ä¸€ä¸‹ä¸Šä¸€å¸§â€œè¶…ç¼–â€çš„æƒ…å†µã€‚  åä¹‹ï¼Œå¦‚æœå½“å‰å¸§å®é™…æ¯”ç‰¹æ•°å°äºæœŸæœ›æ¯”ç‰¹æ•°ï¼Œé‚£ä¹ˆä¸‹ä¸€å¸§å¾—åˆ°çš„ratefactorä¼šæ›´å¤§ï¼Œqscaleæ›´å°ï¼Œç¼–ç æ¯”ç‰¹æ•°ä¼šæ›´å¤šï¼Œåˆ©ç”¨ä¸Šä¸€å¸§â€œæœªç¼–æ»¡â€çš„æƒ…å†µ





#### å°æ€»ç»“

ä¸€å¸§å›¾åƒæ ¹æ®å½“å‰çš„ç¼–ç ä»£ä»·satdã€ä»¥åŠå†å²å¸§çš„ç¼–ç ä»£ä»·ï¼ŒåŠ æƒè®¡ç®—å¾—åˆ°complexityä½œä¸ºå½“å‰å¸§çš„æ¨¡ç³Šå¤æ‚åº¦ï¼Œå°†complexityè¿›è¡Œæ„ŸçŸ¥ç¼–ç ä¼˜åŒ–ï¼Œå¾—åˆ°ä¼˜åŒ–åçš„å›¾åƒå¤æ‚åº¦rcepï¼Œç„¶åqscale = rcep / ratefactorè®¡ç®—å¾—åˆ°qscaleä½œä¸ºå½“å‰å¸§çš„ç¼–ç qscaleã€‚

CRFæ¨¡å¼ï¼Œä¼šå›ºå®šæ­¤ratefactorï¼›ABRæ¨¡å¼ä¼šæ ¹æ®æœŸæœ›ç ç‡å’Œå®é™…ç ç‡çš„åå·®åŠ¨æ€è°ƒèŠ‚ratefactorå€¼ã€‚





## VBVè°ƒæ§

ç»è¿‡â€œç æ§åŸç†åˆ†æâ€çš„å‡ æ­¥æµç¨‹åå·²ç»èƒ½å¤Ÿè·å–qscaleï¼Œå°†qscaleåšé™å¹…å¤„ç†[minQscale, maxQscale]å†è½¬æˆQPï¼Œå°±èƒ½ä½œä¸ºå½“å‰å¸§çš„å¸§çº§QPã€‚

ä½†æ˜¯x264è¿˜æä¾›å¦ä¸€ç§å·¥å…·ï¼ŒVBVï¼Œç”¨äºè¿›ä¸€æ­¥è°ƒèŠ‚ä¸Šé¢æ­¥éª¤å¾—åˆ°çš„qscale



#### 1ã€ä»€ä¹ˆæ˜¯VBVï¼Ÿ

VBVå…¨ç¨‹ä¸ºVideo Buffer Verifierï¼ˆè§†é¢‘ç¼“å†²åŒºæ ¡éªŒå™¨ï¼‰ã€‚ å¯ä»¥å°†VBVå½“åšä¸€ä¸ªå®¹é‡å—é™çš„ç®¡é“ï¼Œæœ‰ä¸€ä¸ªä¸Šé™å®¹é‡å€¼å’Œä¸‹é™å®¹é‡å€¼ï¼Œåœ¨ç»è¿‡æ­¤ç®¡é“çš„è°ƒèŠ‚ä¹‹åèƒ½é™åˆ¶ç¼–ç ç ç‡åœ¨ä¸Šé™å®¹é‡å€¼å’Œä¸‹é™å®¹é‡å€¼ä¹‹å‰ã€‚**ä¸€å¥è¯å°±æ˜¯ä¸ºäº†è¿›ä¸€æ­¥ä¿è¯ç¼–ç ç ç‡çš„ç¨³å®š**

#### 2ã€VBVæ˜¯å¦æ˜¯å¿…é¡»çš„ï¼Ÿ

VBVä¸æ˜¯å¿…é¡»çš„ï¼Œå¯ä»¥æ‰“å¼€ä¹Ÿå¯ä»¥å…³é—­ã€‚CRFã€ABRæ¨¡å¼éƒ½å¯ä»¥ä½¿ç”¨VBVï¼Œä½¿ç”¨VBVèƒ½è¿›ä¸€æ­¥ä¿è¯çš„ç¼–ç ç ç‡çš„ç¨³å®š



#### 3ã€ABRæ¨¡å¼ä¸‹å·²ç»æœ‰äº†åŠ¨æ€è°ƒèŠ‚ratefactorçš„åŠŸèƒ½ï¼Œx264ä¸ºä»€ä¹ˆè¿˜è¦è®¾è®¡vbvï¼Ÿ

è¿™ä¸ªç­”æ¡ˆæ¯”è¾ƒç®€å•ï¼Œå› ä¸ºåŠ¨æ€è°ƒèŠ‚ratefactoråŠŸèƒ½å¯¹äºæ§åˆ¶ç ç‡ä¸Šä¸æ˜¯å¾ˆå‡†ç¡®



#### 4ã€VBVå¦‚ä½•å®ç°ç ç‡è°ƒèŠ‚çš„ï¼Ÿ

*æˆ‘ä»¬å…ˆæ¥çœ‹ä¸€å¹…å›¾*

![](4.ç ç‡æ§åˆ¶.assets/VBVå›¾ç¤º.png)

VBVå¯ä»¥ç†è§£ä¸ºä¸€ä¸ªæ°´æ± ï¼Œæ°´æ± å­˜åœ¨æœ‰é™çš„å®¹é‡å¤§å°ï¼Œä¸”æœ‰ä¸€ä¸ª**æ³¨æ°´å£**å’Œä¸€ä¸ª**å‡ºæ°´å£**ï¼Œ **æ¯ç¼–ç ä¸€å¸§åéƒ½ä¼šå¾€æ°´æ± é‡Œé¢æ³¨å…¥ä¸€éƒ¨åˆ†æ°´ï¼ŒåŒæ—¶ä¹Ÿä¼šæµå‡ºä¸€éƒ¨åˆ†æ°´**ã€‚**æ³¨å…¥çš„æ°´é‡ä¸ºå•å¸§çš„æœŸæœ›æ¯”ç‰¹æ•°ï¼Œæµå‡ºçš„æ°´é‡ä¸ºå®é™…çš„ç¼–ç æ¯”ç‰¹æ•°ã€‚**

å¦‚æœæ³¨æ°´é‡å¤§äºå‡ºæ°´é‡**å³å®é™…ç¼–ç ç ç‡ä½äºç›®æ ‡ç ç‡**ï¼Œé‚£ä¹ˆæ°´æ± çš„æ°´ä¼šæŒç»­ä¸Šæ¶¨ï¼Œç›´è‡³å‘ä¸Šæº¢å‡º(**ç§°ä¹‹ä¸ºVBVä¸Šæº¢å‡ºoverflow**)ï¼› å¦‚æœæ³¨æ°´é‡å°äºå‡ºæ°´é‡å³**å®é™…ç¼–ç ç ç‡é«˜äºç›®æ ‡ç ç‡**ï¼Œé‚£ä¹ˆæ°´æ± çš„æ°´ä¼šæŒç»­ä¸‹é™ï¼Œç›´è‡³æ°´æµå…‰(ç§°ä¹‹ä¸ºVBVä¸‹æº¢å‡ºunderflow)ï¼›

ä¸ºäº†ä¿è¯å®é™…ç ç‡ç­‰äºç›®æ ‡ç ç‡ï¼Œæˆ‘ä»¬å°½é‡è¦ä¿è¯VBVä¸å‡ºç°**ä¸Šæº¢**æˆ–è€…**ä¸‹æº¢**ï¼Œå› æ­¤ç»™æ°´æ± è®¾ç½®ä¸¤æ¡è­¦æˆ’çº¿ï¼Œ**ä¸Šæº¢è­¦æˆ’çº¿å’Œä¸‹æº¢è­¦æˆ’çº¿**ã€‚ å½“æ°´æ± ä¸­çš„æ°´é‡è¶…è¿‡ä¸Šæº¢è­¦æˆ’çº¿æ—¶ä¸ºäº†é¢„é˜²å‡ºç°ä¸Šæº¢ï¼Œéœ€è¦é€‚å½“é™ä½å½“å‰å¸§çš„qscaleï¼Œè®©æ°´é‡åœ¨ç¼–ç åèƒ½å¤Ÿç¨å¾®ä¸‹é™ï¼›åä¹‹å¦‚æœæ°´é‡ä½äºä¸‹æº¢è­¦æˆ’çº¿æ—¶ä¸ºäº†é¢„é˜²å‡ºç°ä¸‹æº¢ï¼Œéœ€è¦é€‚å½“å¢å¤§å½“å‰å¸§çš„qscaleï¼Œè®©æ°´é‡åœ¨ç¼–ç åèƒ½å¤Ÿç¨å¾®ä¸Šå‡ã€‚

è¿™å°±æ˜¯VBVçš„åŸç†ï¼Œè¯¦ç»†ä»‹ç»è§ä¸‹é¢çš„â€œæºç è§£æâ€



## æºç è§£æ

åœ¨â€œx264æ•´ä½“æµç¨‹åˆ†æâ€ç« èŠ‚å·²ç»ä»‹ç»äº†ï¼Œ**x264_ratecontrol_start**æ˜¯å¸§çº§ç æ§çš„å‡½æ•°ï¼Œç»è¿‡x264_ratecontrol_startè®¡ç®—åèƒ½å¤Ÿç¡®å®šå½“å‰å¸§çš„å¸§çº§QPï¼Œè¿™é‡Œå¯¹æ­¤å‡½æ•°è¿›è¡Œåˆ†æ



```c++
// å‡½æ•°ä½ç½®åœ¨encoder/ratecontrol.c
/* Before encoding a frame, choose a QP for it */
void x264_ratecontrol_start( x264_t *h, int i_force_qp, int overhead )
{
    x264_ratecontrol_t *rc = h->rc;
    ratecontrol_entry_t *rce = NULL;
    x264_zone_t *zone = get_zone( h, h->fenc->i_frame );
    float q;  // å½“å‰çš„å¸§çº§QP

    x264_emms();

    if( h->param.rc.b_stat_read )
    {
        // å¦‚æœä»å¤–éƒ¨æ–‡ä»¶è¯»å–ç æ§ä¿¡æ¯æ‰ä¼šè¿›å…¥åˆ°è¿™é‡Œ
        int frame = h->fenc->i_frame;
        assert( frame >= 0 && frame < rc->num_entries );
        rce = rc->rce = &rc->entry[frame];

        if( h->sh.i_type == SLICE_TYPE_B
            && h->param.analyse.i_direct_mv_pred == X264_DIRECT_PRED_AUTO )
        {
            h->sh.b_direct_spatial_mv_pred = ( rce->direct_mode == 's' );
            h->mb.b_direct_auto_read = ( rce->direct_mode == 's' || rce->direct_mode == 't' );
        }
    }

    if( rc->b_vbv )
    {
        // å¦‚æœå¼€å¯äº†VBVä¼šè¿›å…¥åˆ°æ­¤å¤„ï¼Œè¿›è¡Œä¸€äº›åˆå§‹åŒ–çš„å·¥ä½œ
        memset( h->fdec->i_row_bits, 0, h->mb.i_mb_height * sizeof(int) );
        memset( h->fdec->f_row_qp, 0, h->mb.i_mb_height * sizeof(float) );
        memset( h->fdec->f_row_qscale, 0, h->mb.i_mb_height * sizeof(float) );
        rc->row_pred = rc->row_preds[h->sh.i_type];
        rc->buffer_rate = h->fenc->i_cpb_duration * rc->vbv_max_rate * h->sps->vui.i_num_units_in_tick / h->sps->vui.i_time_scale;
        update_vbv_plan( h, overhead );

        const x264_level_t *l = x264_levels;
        while( l->level_idc != 0 && l->level_idc != h->param.i_level_idc )
            l++;

        int mincr = l->mincr;

        if( h->param.b_bluray_compat )
            mincr = 4;

        /* Profiles above High don't require minCR, so just set the maximum to a large value. */
        if( h->sps->i_profile_idc > PROFILE_HIGH )
            rc->frame_size_maximum = 1e9;
        else
        {
            /* The spec has a bizarre special case for the first frame. */
            if( h->i_frame == 0 )
            {
                //384 * ( Max( PicSizeInMbs, fR * MaxMBPS ) + MaxMBPS * ( tr( 0 ) - tr,n( 0 ) ) ) / MinCR
                double fr = 1. / (h->param.i_level_idc >= 60 ? 300 : 172);
                int pic_size_in_mbs = h->mb.i_mb_width * h->mb.i_mb_height;
                rc->frame_size_maximum = 384 * BIT_DEPTH * X264_MAX( pic_size_in_mbs, fr*l->mbps ) / mincr;
            }
            else
            {
                //384 * MaxMBPS * ( tr( n ) - tr( n - 1 ) ) / MinCR
                rc->frame_size_maximum = 384 * BIT_DEPTH * ((double)h->fenc->i_cpb_duration * h->sps->vui.i_num_units_in_tick / h->sps->vui.i_time_scale) * l->mbps / mincr;
            }
        }
    }

    if( h->sh.i_type != SLICE_TYPE_B )
        rc->bframes = h->fenc->i_bframes;

    if( rc->b_abr )
    {
        // ABRã€CRFç æ§æ–¹å¼ä¼šè¿›å…¥åˆ°æ­¤æ¡ä»¶ä¸‹ï¼Œè®¡ç®—å¾—åˆ°å¸§çº§QPèµ‹å€¼ç»™q
        q = qscale2qp( rate_estimate_qscale( h ) );
    }
    else if( rc->b_2pass )
    {
        // 2pass ç¼–ç 
        rce->new_qscale = rate_estimate_qscale( h );
        q = qscale2qp( rce->new_qscale );
    }
    else /* CQP */
    {
        // CQPçš„ç æ§ä¼šè¿›å…¥åˆ°æ­¤æ¡ä»¶ä¸­ï¼Œæ ¹æ®å½“å‰çš„å¸§ç±»å‹ä»¥åŠqp_constantå¾—åˆ°ä¸€ä¸ªå›ºå®šçš„QPå€¼
        if( h->sh.i_type == SLICE_TYPE_B && h->fdec->b_kept_as_ref )
            q = ( rc->qp_constant[ SLICE_TYPE_B ] + rc->qp_constant[ SLICE_TYPE_P ] ) / 2;
        else
            q = rc->qp_constant[ h->sh.i_type ];

        if( zone )
        {
            if( zone->b_force_qp )
                q += zone->i_qp - rc->qp_constant[SLICE_TYPE_P];
            else
                q -= 6*log2f( zone->f_bitrate_factor );
        }
    }
    if( i_force_qp != X264_QP_AUTO )
        q = i_force_qp - 1;

    // é™å¹…åœ¨[h->param.rc.i_qp_minï¼Œh->param.rc.i_qp_max]
    q = x264_clip3f( q, h->param.rc.i_qp_min, h->param.rc.i_qp_max );

    rc->qpa_rc = rc->qpa_rc_prev =
    rc->qpa_aq = rc->qpa_aq_prev = 0;
    h->fdec->f_qp_avg_rc =
    h->fdec->f_qp_avg_aq =
    rc->qpm = q; // ä¿å­˜å½“å‰çš„qp
    if( rce )
        rce->new_qp = q;
	
    // æ›´æ–°accum_p_qpå’Œaccum_p_norm
    accum_p_qp_update( h, rc->qpm );

    if( h->sh.i_type != SLICE_TYPE_B )
        rc->last_non_b_pict_type = h->sh.i_type;
}
```



```c++
/* qscaleè½¬qpçš„å‡½æ•° */
static inline float qscale2qp( float qscale )
{
    // å‚è€ƒâ€œåŸºæœ¬å…¬å¼â€
    return (12.0f + QP_BD_OFFSET) + 6.0f * log2f( qscale/0.85f );
}
```



```c++
/* æ›´æ–°accum_p_qpå’Œaccum_p_norm */
static void accum_p_qp_update( x264_t *h, float qp ){
    // accum_p_qpæ˜¯ä¸€ä¸ªå†å²å¸§qpçš„ç´¯åŠ å€¼ã€‚å¦‚æœæŸä¸€å¸§æ˜¯IDR/Iå¸§æ—¶å¯ä»¥é€šè¿‡accum_p_qpå»è°ƒæ•´IDR/Iå¸§çš„qpï¼Œé¿å…å…¶è¿‡å¤§æˆ–è€…è¿‡å°
    x264_ratecontrol_t *rc = h->rc;
    rc->accum_p_qp   *= .95;
    rc->accum_p_norm *= .95;
    rc->accum_p_norm += 1;
    if( h->sh.i_type == SLICE_TYPE_I )
        rc->accum_p_qp += qp + rc->ip_offset;
    else
        rc->accum_p_qp += qp;
}
```



```c++
/* è®¡ç®—å½“å‰å¸§çš„qscale */
static float rate_estimate_qscale( x264_t *h )
{
    float q;
    x264_ratecontrol_t *rcc = h->rc;
    ratecontrol_entry_t rce = {0};
    int pict_type = h->sh.i_type;
    /* è·å–æ‰€æœ‰å·²ç»ç¼–ç å¸§çš„æ€»å¤§å°(ä¸ç®—filterå¡«å……çš„æ•°é‡) */
    int64_t total_bits = 8*(h->stat.i_frame_size[SLICE_TYPE_I]
                          + h->stat.i_frame_size[SLICE_TYPE_P]
                          + h->stat.i_frame_size[SLICE_TYPE_B])
                       - rcc->filler_bits_sum;

    if( rcc->b_2pass )
    {
        // 2pass
        rce = *rcc->rce;
        if( pict_type != rce.pict_type )
        {
            x264_log( h, X264_LOG_ERROR, "slice=%c but 2pass stats say %c\n",
                      slice_type_to_char[pict_type], slice_type_to_char[rce.pict_type] );
        }
    }

    if( pict_type == SLICE_TYPE_B )
    {
        /* B-frames don't have independent ratecontrol, but rather get the
         * average QP of the two adjacent P-frames + an offset */

        int i0 = IS_X264_TYPE_I(h->fref_nearest[0]->i_type);
        int i1 = IS_X264_TYPE_I(h->fref_nearest[1]->i_type);
        int dt0 = abs(h->fenc->i_poc - h->fref_nearest[0]->i_poc); // ä¸å‰å‘é˜Ÿåˆ—ä¸­æœ€è¿‘ä¸€å¸§å‚è€ƒå¸§çš„è·ç¦»
        int dt1 = abs(h->fenc->i_poc - h->fref_nearest[1]->i_poc); // ä¸åå‘é˜Ÿåˆ—ä¸­æœ€è¿‘ä¸€å¸§å‚è€ƒå¸§çš„è·ç¦»
        float q0 = h->fref_nearest[0]->f_qp_avg_rc; // å‰å‘æœ€è¿‘ä¸€å¸§å‚è€ƒå¸§çš„å¹³å‡å®å—QP
        float q1 = h->fref_nearest[1]->f_qp_avg_rc; // åå‘æœ€è¿‘ä¸€å¸§å‚è€ƒå¸§çš„å¹³å‡å®å—QP

        // å¦‚æœæœ€è¿‘ä¸€å¸§å‚è€ƒå¸§çš„B-REFï¼Œq0/q1å‡å»ä¸€ä¸ªåç§»å€¼
        if( h->fref_nearest[0]->i_type == X264_TYPE_BREF )
            q0 -= rcc->pb_offset/2;
        if( h->fref_nearest[1]->i_type == X264_TYPE_BREF )
            q1 -= rcc->pb_offset/2;
		
        // æ ¹æ®å‰å‘ã€åå‘æœ€è¿‘ä¸€å¸§å‚è€ƒå¸§çš„å¸§ç±»å‹ç¡®å®šå½“å‰qå€¼
        if( i0 && i1 )
            q = (q0 + q1) / 2 + rcc->ip_offset;
        else if( i0 )
            q = q1;
        else if( i1 )
            q = q0;
        else
            q = (q0*dt1 + q1*dt0) / (dt0 + dt1);
		
        // å½“å‰å¸§æ˜¯å¦å¯ä»¥ä½œä¸ºå‚è€ƒå¸§ï¼ŒqåŠ ä¸Šä¸åŒçš„åç§»å€¼
        if( h->fenc->b_kept_as_ref )
            q += rcc->pb_offset/2;
        else
            q += rcc->pb_offset;

        rcc->qp_novbv = q;
        q = qp2qscale( q );
        if( rcc->b_2pass )
            rcc->frame_size_planned = qscale2bits( &rce, q );
        else
            rcc->frame_size_planned = predict_size( rcc->pred_b_from_p, q, h->fref[1][h->i_ref[1]-1]->i_satd );
        /* Limit planned size by MinCR */
        if( rcc->b_vbv )
            rcc->frame_size_planned = X264_MIN( rcc->frame_size_planned, rcc->frame_size_maximum );
        rcc->frame_size_estimated = rcc->frame_size_planned;

        /* For row SATDs */
        if( rcc->b_vbv )
            rcc->last_satd = x264_rc_analyse_slice( h );
        return q;
    }
    else
    {
        double abr_buffer = 2 * rcc->rate_tolerance * rcc->bitrate;
        double predicted_bits = total_bits;
        if( h->i_thread_frames > 1 )
        {
            int j = rcc - h->thread[0]->rc;
            for( int i = 1; i < h->i_thread_frames; i++ )
            {
                x264_t *t = h->thread[(j+i) % h->i_thread_frames];
                double bits = t->rc->frame_size_planned;
                if( !t->b_thread_active )
                    continue;
                bits = X264_MAX(bits, t->rc->frame_size_estimated);
                predicted_bits += bits;
            }
        }

        if( rcc->b_2pass )
        {
            // 2pass
            double lmin = rcc->lmin[pict_type];
            double lmax = rcc->lmax[pict_type];
            double diff;

            /* Adjust ABR buffer based on distance to the end of the video. */
            if( rcc->num_entries > h->i_frame )
            {
                double final_bits = rcc->entry_out[rcc->num_entries-1]->expected_bits;
                double video_pos = rce.expected_bits / final_bits;
                double scale_factor = sqrt( (1 - video_pos) * rcc->num_entries );
                abr_buffer *= 0.5 * X264_MAX( scale_factor, 0.5 );
            }

            diff = predicted_bits - rce.expected_bits;
            q = rce.new_qscale;
            q /= x264_clip3f((abr_buffer - diff) / abr_buffer, .5, 2);
            if( h->i_frame >= rcc->fps && rcc->expected_bits_sum >= 1 )
            {
                /* Adjust quant based on the difference between
                 * achieved and expected bitrate so far */
                double cur_time = (double)h->i_frame / rcc->num_entries;
                double w = x264_clip3f( cur_time*100, 0.0, 1.0 );
                q *= pow( (double)total_bits / rcc->expected_bits_sum, w );
            }
            rcc->qp_novbv = qscale2qp( q );
            if( rcc->b_vbv )
            {
                /* Do not overflow vbv */
                double expected_size = qscale2bits( &rce, q );
                double expected_vbv = rcc->buffer_fill + rcc->buffer_rate - expected_size;
                double expected_fullness = rce.expected_vbv / rcc->buffer_size;
                double qmax = q*(2 - expected_fullness);
                double size_constraint = 1 + expected_fullness;
                qmax = X264_MAX( qmax, rce.new_qscale );
                if( expected_fullness < .05 )
                    qmax = lmax;
                qmax = X264_MIN(qmax, lmax);
                while( ((expected_vbv < rce.expected_vbv/size_constraint) && (q < qmax)) ||
                        ((expected_vbv < 0) && (q < lmax)))
                {
                    q *= 1.05;
                    expected_size = qscale2bits(&rce, q);
                    expected_vbv = rcc->buffer_fill + rcc->buffer_rate - expected_size;
                }
                rcc->last_satd = x264_rc_analyse_slice( h );
            }
            q = x264_clip3f( q, lmin, lmax );
        }
        else /* 1pass ABR */
        {
            /* Calculate the quantizer which would have produced the desired
             * average bitrate if it had been applied to all frames so far.
             * Then modulate that quant based on the current frame's complexity
             * relative to the average complexity so far (using the 2pass RCEQ).
             * Then bias the quant up or down if total size so far was far from
             * the target.
             * Result: Depending on the value of rate_tolerance, there is a
             * tradeoff between quality and bitrate precision. But at large
             * tolerances, the bit distribution approaches that of 2pass. */

            double wanted_bits, overflow = 1;

            rcc->last_satd = x264_rc_analyse_slice( h ); // å½“å‰å¸§çš„satd(ç¼–ç ä»£ä»·)
            // æ›´æ–°short_term_cplxsumã€short_term_cplxcount
            rcc->short_term_cplxsum *= 0.5;  // å†å²å€¼ä¹˜ä¸Š0.5ï¼Œä¸ºäº†é™ä½å†å²å¸§çš„å½±å“
            rcc->short_term_cplxcount *= 0.5;
            rcc->short_term_cplxsum += rcc->last_satd / (CLIP_DURATION(h->fenc->f_duration) / BASE_FRAME_DURATION);
            rcc->short_term_cplxcount ++;

            rce.tex_bits = rcc->last_satd;
            // è·å–å½“å‰å¸§çš„æ¨¡ç³Šå¤æ‚åº¦
            rce.blurred_complexity = rcc->short_term_cplxsum / rcc->short_term_cplxcount;
            rce.mv_bits = 0;
            rce.p_count = rcc->nmb;
            rce.i_count = 0;
            rce.s_count = 0;
            rce.qscale = 1;
            rce.pict_type = pict_type;
            rce.i_duration = h->fenc->i_duration;

            if( h->param.rc.i_rc_method == X264_RC_CRF )
            {
                // CRFç æ§ï¼Œrcc->rate_factor_constantä¸ºå›ºå®šå€¼
                q = get_qscale( h, &rce, rcc->rate_factor_constant, h->fenc->i_frame );
            }
            else
            {
                // ABRç æ§ï¼Œwanted_bits_windowã€cplxr_sumä¼šåœ¨x264_ratecontrol_endæ›´æ–°
                q = get_qscale( h, &rce, rcc->wanted_bits_window / rcc->cplxr_sum, h->fenc->i_frame );

                /* ABR code can potentially be counterproductive in CBR, so just don't bother.
                 * Don't run it if the frame complexity is zero either. */
                if( !rcc->b_vbv_min_rate && rcc->last_satd )
                {
                    // è¿™é‡Œåªæœ‰vbv_max_bitrate > rc.i_bitrateæ—¶æ‰æœ‰å¯èƒ½è¿›å…¥åˆ°æ­¤æ¡ä»¶ä¸­
                    // FIXME is it simpler to keep track of wanted_bits in ratecontrol_end?
                    int i_frame_done = h->i_frame;
                    double time_done = i_frame_done / rcc->fps; // å·²ç»ç¼–ç çš„æ€»æ—¶é—´(ä»¥fpså¸§/sæ¥è®¡ç®—)
                    if( h->param.b_vfr_input && i_frame_done > 0 )
                        time_done = ((double)(h->fenc->i_reordered_pts - h->i_reordered_pts_delay)) * h->param.i_timebase_num / h->param.i_timebase_den;
                    wanted_bits = time_done * rcc->bitrate; // time_doneç§’ç¼–ç æœŸæœ›çš„æ€»æ¯”ç‰¹æ•°
                    if( wanted_bits > 0 )
                    {
                        // æº¢å‡ºåˆ¤æ–­
                        abr_buffer *= X264_MAX( 1, sqrt( time_done ) );
                        overflow = x264_clip3f( 1.0 + (predicted_bits - wanted_bits) / abr_buffer, .5, 2 );
                        q *= overflow;
                    }
                }
            }
			
            // è°ƒæ•´qscaleå€¼
            if( pict_type == SLICE_TYPE_I && h->param.i_keyint_max > 1
                /* should test _next_ pict type, but that isn't decided yet */
                && rcc->last_non_b_pict_type != SLICE_TYPE_I )
            {
                /* 
            		å¦‚æœå½“å‰å¸§æ—¶IDR/Iå¸§ï¼Œi_keyint_max > 1å¹¶ä¸”ä¸Šä¸€å¸§éBå¸§ä¸æ˜¯IDR/Iå¸§ï¼Œä¼šé€šè¿‡å†å²å¸§çš„qpè®¡ç®—å‡ºå½“å‰å¸§çš„qscale
            		ç›®çš„æ˜¯ä¸ºäº†é˜²æ­¢å½“å‰å¸§çš„qscaleå¼‚å¸¸è¿‡å¤§æˆ–è€…è¿‡å°ã€‚ rcc->accum_p_qpå’Œrcc->accum_p_normçš„æ›´æ–°è§accum_p_qp_updateå‡½æ•°
            	*/
                q = qp2qscale( rcc->accum_p_qp / rcc->accum_p_norm );
                q /= fabs( h->param.rc.f_ip_factor );
            }
            else if( h->i_frame > 0 ) // éé¦–å¸§
            {
                if( h->param.rc.i_rc_method != X264_RC_CRF )
                {
                    // é€šè¿‡lminï¼Œlmaxé™åˆ¶qçš„åŒºé—´
                    /* Asymmetric clipping, because symmetric would prevent
                     * overflow control in areas of rapidly oscillating complexity */
                    double lmin = rcc->last_qscale_for[pict_type] / rcc->lstep;
                    double lmax = rcc->last_qscale_for[pict_type] * rcc->lstep;
                    if( overflow > 1.1 && h->i_frame > 3 )
                        lmax *= rcc->lstep;
                    else if( overflow < 0.9 )
                        lmin /= rcc->lstep;

                    q = x264_clip3f(q, lmin, lmax);
                }
            }
            else if( h->param.rc.i_rc_method == X264_RC_CRF && rcc->qcompress != 1 )
            {
                q = qp2qscale( ABR_INIT_QP ) / fabs( h->param.rc.f_ip_factor );
            }
            rcc->qp_novbv = qscale2qp( q ); // ä¿å­˜å½“å‰å¸§çš„qp(æœªç»è¿‡vbvçš„è°ƒæ•´å‰çš„qp)

            //FIXME use get_diff_limited_q() ?
            // VBVè°ƒæ§
            q = clip_qscale( h, pict_type, q );
        }

        rcc->last_qscale_for[pict_type] =
        rcc->last_qscale = q;

        if( !(rcc->b_2pass && !rcc->b_vbv) && h->fenc->i_frame == 0 )
            rcc->last_qscale_for[SLICE_TYPE_P] = q * fabs( h->param.rc.f_ip_factor );

        if( rcc->b_2pass )
            rcc->frame_size_planned = qscale2bits( &rce, q );
        else
            rcc->frame_size_planned = predict_size( &rcc->pred[h->sh.i_type], q, rcc->last_satd );

        /* Always use up the whole VBV in this case. */
        if( rcc->single_frame_vbv )
            rcc->frame_size_planned = rcc->buffer_rate;
        /* Limit planned size by MinCR */
        if( rcc->b_vbv )
            rcc->frame_size_planned = X264_MIN( rcc->frame_size_planned, rcc->frame_size_maximum );
        rcc->frame_size_estimated = rcc->frame_size_planned;
        return q;
    }
}
```



**æ ¹æ®æ¨¡ç³Šå¤æ‚åº¦ã€ratefactorè·å–å½“å‰å¸§çš„qscale**

```c++
/* æ ¹æ®æ¨¡ç³Šå¤æ‚åº¦ã€ratefactorè·å–å½“å‰å¸§çš„qscale */
static double get_qscale(x264_t *h, ratecontrol_entry_t *rce, double rate_factor, int frame_num)
{
    x264_ratecontrol_t *rcc= h->rc;
    x264_zone_t *zone = get_zone( h, frame_num );
    double q;
    if( h->param.rc.b_mb_tree )
    {
        double timescale = (double)h->sps->vui.i_num_units_in_tick / h->sps->vui.i_time_scale;
        q = pow( BASE_FRAME_DURATION / CLIP_DURATION(rce->i_duration * timescale), 1 - h->param.rc.f_qcompress );
    }
    else
        q = pow( rce->blurred_complexity, 1 - rcc->qcompress ); // å¯¹æ¨¡ç³Šå¤æ‚åº¦è¿›è¡Œæ„ŸçŸ¥ç¼–ç ä¼˜åŒ–ï¼Œå¾—åˆ°recq

    // avoid NaN's in the rc_eq
    if( !isfinite(q) || rce->tex_bits + rce->mv_bits == 0 )
        q = rcc->last_qscale_for[rce->pict_type];
    else
    {
        rcc->last_rceq = q;
        q /= rate_factor;  // recq / rate_factorå¾—åˆ°å½“å‰qscale
        rcc->last_qscale = q;
    }

    if( zone )
    {
        if( zone->b_force_qp )
            q = qp2qscale( zone->i_qp );
        else
            q /= zone->f_bitrate_factor;
    }

    return q;
}

```



**VBVè°ƒæ§ï¼Œå¹¶ä¸”é™åˆ¶qscaleåœ¨[lmin,lmax]ä¹‹é—´**

```c++
// apply VBV constraints and clip qscale to between lmin and lmax
static double clip_qscale( x264_t *h, int pict_type, double q )
{
    x264_ratecontrol_t *rcc = h->rc;
    double lmin = rcc->lmin[pict_type];
    double lmax = rcc->lmax[pict_type];
    if( rcc->rate_factor_max_increment )
        lmax = X264_MIN( lmax, qp2qscale( rcc->qp_novbv + rcc->rate_factor_max_increment ) );
    double q0 = q;

    /* B-frames are not directly subject to VBV,
     * since they are controlled by the P-frames' QPs. */

    if( rcc->b_vbv && rcc->last_satd > 0 )
    {
        // å¦‚æœå¼€å¯äº†vbv
        double fenc_cpb_duration = (double)h->fenc->i_cpb_duration *
                                   h->sps->vui.i_num_units_in_tick / h->sps->vui.i_time_scale;
        /* Lookahead VBV: raise the quantizer as necessary such that no frames in
         * the lookahead overflow and such that the buffer is in a reasonable state
         * by the end of the lookahead. */
        if( h->param.rc.i_lookahead )
        {
            // å¦‚æœå¼€å¯äº†lookahead
            int terminate = 0;

            /* Avoid an infinite loop. */
            for( int iterations = 0; iterations < 1000 && terminate != 3; iterations++ )
            {
                double frame_q[3];
                // æ ¹æ®å½“å‰å¸§ç±»å‹ï¼Œqscaleï¼Œsatdé¢„æµ‹å½“å‰å¸§ä»¥qscaleçš„é‡åŒ–ç­‰çº§è¿›è¡Œç¼–ç ç¼–ç åçš„æ¯”ç‰¹æ•°cur_bits
                double cur_bits = predict_size( &rcc->pred[h->sh.i_type], q, rcc->last_satd );
                // buffet_fillä¸ºå½“å‰VBVæ°´æ± çš„æ°´é‡ï¼Œæµå‡ºcur_bitsçš„æ°´å‰©ä½™çš„æ°´é‡ä¸ºbuffer_fill_cur
                double buffer_fill_cur = rcc->buffer_fill - cur_bits;
                double target_fill;
                double total_duration = 0;
                double last_duration = fenc_cpb_duration;
                frame_q[0] = h->sh.i_type == SLICE_TYPE_I ? q * h->param.rc.f_ip_factor : q;
                frame_q[1] = frame_q[0] * h->param.rc.f_pb_factor;
                frame_q[2] = frame_q[0] / h->param.rc.f_ip_factor;

                /* Loop over the planned future frames. */
                for( int j = 0; buffer_fill_cur >= 0 && buffer_fill_cur <= rcc->buffer_size; j++ )
                {
                    // lookaheadï¼Œå¾€åé¢„æµ‹ä¸€å®šæ•°é‡çš„å¸§ï¼Œæ›´æ–°buffer_fill_cur
                    total_duration += last_duration;
                    buffer_fill_cur += rcc->vbv_max_rate * last_duration; // "æ³¨æ°´"ï¼Œæ³¨æ°´é‡ä¸ºç ç‡/fps
                    int i_type = h->fenc->i_planned_type[j];
                    int i_satd = h->fenc->i_planned_satd[j];
                    if( i_type == X264_TYPE_AUTO )
                        break;
                    i_type = IS_X264_TYPE_I( i_type ) ? SLICE_TYPE_I : IS_X264_TYPE_B( i_type ) ? SLICE_TYPE_B : SLICE_TYPE_P;
                    cur_bits = predict_size( &rcc->pred[i_type], frame_q[i_type], i_satd );
                    buffer_fill_cur -= cur_bits;
                    last_duration = h->fenc->f_planned_cpb_duration[j];
                }
                /* Try to get to get the buffer at least 50% filled, but don't set an impossible goal. */
                // æ°´æ± ç»è¿‡â€œå‡ºæ°´â€â€œæ³¨æ°´â€åçš„ç›®æ ‡æ°´é‡target_fillï¼Œæœ€å°ä¸º0.5 * æ°´æ± å®¹é‡ï¼Œbuffer_sizeä¸ºvbvçš„æ°´æ± å®¹é‡
                target_fill = X264_MIN( rcc->buffer_fill + total_duration * rcc->vbv_max_rate * 0.5, rcc->buffer_size * 0.5 );
                // é¢„é˜²æ°´æ± ä¸‹æº¢
                if( buffer_fill_cur < target_fill )
                {
                    // å¦‚æœå½“å‰æ°´æ± ç»è¿‡â€œæ³¨æ°´â€â€œå‡ºæ°´â€åæ°´é‡ä»ç„¶ä½äºtarget_fillï¼Œè¯´æ˜â€œå‡ºæ°´â€é‡è¿‡å¤šï¼Œå³ç¼–ç åæ¯”ç‰¹æ•°è¿‡å¤šï¼Œåº”è¯¥é™ä½ç¼–ç æ¯”ç‰¹æ•°ï¼Œæ‰€ä»¥å¢å¤§qscale
                    q *= 1.01;
                    terminate |= 1;
                    continue;
                }
                /* Try to get the buffer no more than 80% filled, but don't set an impossible goal. */
                // ç›®å‰æ°´é‡target_fillï¼Œæœ€å¤§å€¼ä¸º0.8 * æ°´æ± å®¹é‡
                target_fill = x264_clip3f( rcc->buffer_fill - total_duration * rcc->vbv_max_rate * 0.5, rcc->buffer_size * 0.8, rcc->buffer_size );
                // é¢„é˜²æ°´æ± ä¸Šæº¢
                if( rcc->b_vbv_min_rate && buffer_fill_cur > target_fill )
                {
                    // å¦‚æœå½“å‰æ°´æ± ç»è¿‡â€œæ³¨æ°´â€â€œå‡ºæ°´â€åæ°´é‡é«˜äºtarget_fillï¼Œè¯´æ˜â€œå‡ºæ°´â€é‡è¿‡å°‘ï¼Œå³ç¼–ç åæ¯”ç‰¹æ•°è¿‡å°‘ï¼Œåº”è¯¥å¢å¤§ç¼–ç æ¯”ç‰¹æ•°ï¼Œæ‰€ä»¥é™ä½
                    q /= 1.01;
                    terminate |= 2;
                    continue;
                }
                break;
            }
        }
        /* Fallback to old purely-reactive algorithm: no lookahead. */
        else
        {
            // no lookahead
            if( ( pict_type == SLICE_TYPE_P ||
                ( pict_type == SLICE_TYPE_I && rcc->last_non_b_pict_type == SLICE_TYPE_I ) ) &&
                rcc->buffer_fill/rcc->buffer_size < 0.5 )
            {
                // å¦‚æœå½“å‰å¸§æ—¶På¸§æˆ–è€…å½“å‰å¸§æ—¶Iå¸§ä¸”ä¸Šä¸€å¸§éBå¸§ä¹Ÿæ˜¯Iå¸§ï¼Œå¦‚æœå½“å‰æ°´æ± çš„æ°´é‡å°äº0.5 * æ°´æ± å®¹é‡ï¼Œä¸ºäº†é¿å…ä¸‹æº¢ï¼Œå¢å¤§qscale
                q /= x264_clip3f( 2.0*rcc->buffer_fill/rcc->buffer_size, 0.5, 1.0 );
            }

            /* Now a hard threshold to make sure the frame fits in VBV.
             * This one is mostly for I-frames. */
            // æ ¹æ®å½“å‰å¸§ç±»å‹ï¼Œqscaleï¼Œsatdé¢„æµ‹å½“å‰å¸§ä»¥qscaleçš„é‡åŒ–ç­‰çº§è¿›è¡Œç¼–ç ç¼–ç åçš„æ¯”ç‰¹æ•°bits
            double bits = predict_size( &rcc->pred[h->sh.i_type], q, rcc->last_satd );
            /* For small VBVs, allow the frame to use up the entire VBV. */
            // æœ€å¤§fill factor
            double max_fill_factor = h->param.rc.i_vbv_buffer_size >= 5*h->param.rc.i_vbv_max_bitrate / rcc->fps ? 2 : 1;
            /* For single-frame VBVs, request that the frame use up the entire VBV. */
            // æœ€å°fill factor
            double min_fill_factor = rcc->single_frame_vbv ? 1 : 2;

            if( bits > rcc->buffer_fill/max_fill_factor )
            {
                // å½“å‰bitsè¶…è¿‡buffer_fill/max_fill_factoï¼Œä¸ºäº†é¿å…ä¸‹æº¢ï¼Œå¢åŠ qscale
                double qf = x264_clip3f( rcc->buffer_fill/(max_fill_factor*bits), 0.2, 1.0 );
                q /= qf;
                bits *= qf;
            }
            if( bits < rcc->buffer_rate/min_fill_factor )
            {
                // åŒç†ï¼Œä¸ºäº†é¿å…ä¸Šæº¢ï¼Œé™ä½qscaleã€
                double qf = x264_clip3f( bits*min_fill_factor/rcc->buffer_rate, 0.001, 1.0 );
                q *= qf;
            }
            q = X264_MAX( q0, q );
        }

        /* Check B-frame complexity, and use up any bits that would
         * overflow before the next P-frame. */
        // æ ¹æ®Bå¸§é¢„æµ‹å¤§å°è°ƒæ•´qscaleï¼Œé¿å…å‘ç”Ÿæº¢å‡º
        if( h->sh.i_type == SLICE_TYPE_P && !rcc->single_frame_vbv )
        {
            int nb = rcc->bframes;
            double bits = predict_size( &rcc->pred[h->sh.i_type], q, rcc->last_satd );
            double pbbits = bits;
            double bbits = predict_size( rcc->pred_b_from_p, q * h->param.rc.f_pb_factor, rcc->last_satd );
            double space;
            double bframe_cpb_duration = 0;
            double minigop_cpb_duration;
            for( int i = 0; i < nb; i++ )
                bframe_cpb_duration += h->fenc->f_planned_cpb_duration[i];

            if( bbits * nb > bframe_cpb_duration * rcc->vbv_max_rate )
                nb = 0;
            pbbits += nb * bbits;

            minigop_cpb_duration = bframe_cpb_duration + fenc_cpb_duration;
            space = rcc->buffer_fill + minigop_cpb_duration*rcc->vbv_max_rate - rcc->buffer_size;
            if( pbbits < space )
            {
                q *= X264_MAX( pbbits / space, bits / (0.5 * rcc->buffer_size) );
            }
            q = X264_MAX( q0/2, q );
        }

        /* Apply MinCR and buffer fill restrictions */
        double bits = predict_size( &rcc->pred[h->sh.i_type], q, rcc->last_satd );
        double frame_size_maximum = X264_MIN( rcc->frame_size_maximum, X264_MAX( rcc->buffer_fill, 0.001 ) );
        if( bits > frame_size_maximum )
            q *= bits / frame_size_maximum;

        if( !rcc->b_vbv_min_rate )
            q = X264_MAX( q0, q );
    }

    if( lmin==lmax )
        return lmin;
    else if( rcc->b_2pass )
    {
        double min2 = log( lmin );
        double max2 = log( lmax );
        q = (log(q) - min2)/(max2-min2) - 0.5;
        q = 1.0/(1.0 + exp( -4*q ));
        q = q*(max2-min2) + min2;
        return exp( q );
    }
    else
        return x264_clip3f( q, lmin, lmax ); // é™å¹…åœ¨[lmin, lmax]ä¹‹é—´
}
```



æ–‡ä¸­æœ‰ä½¿ç”¨predict_sizeå‡½æ•°æ¥é¢„æµ‹å½“å‰å¸§ç¼–ç åçš„æ•°æ®å¤§å°ï¼Œæ­¤ç®—æ³•çš„åŸç†å¯ä»¥å‚è€ƒ[æ¯”ç‰¹é¢„æµ‹å™¨(predictor)](æ¯”ç‰¹é¢„æµ‹å™¨(predictor).md)ç« èŠ‚



## å‚è€ƒå¼•ç”¨

ğŸ±â€ğŸhttps://github.com/mirror/x264

ğŸ±â€ğŸhttps://blog.csdn.net/soulmate_scut/article/details/89178017
