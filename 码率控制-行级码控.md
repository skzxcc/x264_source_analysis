## å‰è¨€

[ç ç‡æ§åˆ¶-å¸§çº§ç æ§](./ç ç‡æ§åˆ¶-å¸§çº§ç æ§.md)ç« èŠ‚å·²ç»ä»‹ç»äº†å¸§çº§ç ç‡æ§åˆ¶çš„åŸç†ï¼Œç”¨ä¸€å¥è¯æ¦‚æ‹¬å°±æ˜¯**â€ç»“åˆç æ§æ–¹å¼ã€å®é™…ç ç‡ã€ç›®æ ‡ç ç‡ã€VBVç­‰ç­‰å› ç´ ï¼Œç»™å½“å‰å¸§è®¾ç½®ä¸€ä¸ªåˆé€‚çš„å¸§çº§QPâ€œ**

*1ã€æ—¢ç„¶å¸§çº§QPå·²ç»ç¡®å®šäº†ï¼Œé‚£ä¹ˆæ˜¯ä¸æ˜¯å½“å‰å¸§çš„æ‰€æœ‰å®å—éƒ½ä»¥å¸§çº§QPè¿›è¡Œé‡åŒ–çš„å‘¢ï¼Ÿ(ä¸ªäººçœ‹æ³•)*

ç­”æ¡ˆè‚¯å®šä¸æ˜¯çš„(å½“ç„¶è¿™é‡Œæˆ‘ä»¬å…ˆå¿½ç•¥AQã€MB-Treeç­‰çš„å½±å“)ï¼Œå› ä¸ºçœŸæ­£è½å®åˆ°ç¼–ç çš„å•ä½æ˜¯å®å—ï¼Œå¸§çº§QPå¯ä»¥è®¤ä¸ºæ˜¯ä¸€ä¸ªå®å—QPçš„åŸºç¡€å€¼ï¼Œæ­£å¸¸æƒ…å†µä¸‹å®å—éƒ½æ˜¯æ ¹æ®æ­¤QPåŸºç¡€å€¼è¿›è¡Œç¼–ç çš„ï¼Œä½†æ˜¯æ­¤å€¼çš„é¢„æµ‹å¹¶ä¸æ˜¯å¾ˆå‡†ç¡®çš„ï¼Œå³æ‰€æœ‰å®å—ä»¥å¸§çº§QPè¿›è¡Œé‡åŒ–ä¹Ÿæœ‰å¯èƒ½å‡ºç°â€è¶…ç¼–â€œæˆ–è€…â€ç¼–ä¸æ»¡â€œçš„æƒ…å†µï¼Œå› æ­¤éœ€è¦è¿›è¡Œå®å—QPçº§åˆ«çš„è°ƒæ§ï¼Œ*ç¼–ç ä¸€å¸§çš„è¿‡ç¨‹ä¸­å¦‚æœå‘ç°â€è¶…ç¼–â€œçš„æƒ…å†µä¼šè°ƒé«˜å®å—QPåŸºç¡€å€¼ï¼Œå¦‚æœâ€ç¼–ä¸æ»¡â€œåˆ™ä¼šé™ä½å®å—QPåŸºç¡€å€¼*ï¼Œä»¥æ­¤æ–¹æ³•è¿›ä¸€æ­¥ä¿è¯ç ç‡çš„ç¨³å®šã€‚

ï¼ˆhttps://zhuanlan.zhihu.com/p/477766087ï¼Œä½†æ–‡ç« æŒ‡å‡ºx265çš„VBVå¯¹ç æ§çš„æ•ˆæœä¸å¤§ï¼‰



*2ã€æ—¢ç„¶æ˜¯å¯¹å®å—QPåŸºç¡€å€¼è¿›è¡Œè°ƒæ•´ï¼Œä¸ºä»€ä¹ˆå«**è¡Œçº§ç æ§**è€Œä¸æ˜¯**å®å—çº§ç æ§**å‘¢ï¼Ÿ*

è¿™ä¸x264çš„å®ç°æœ‰å…³ï¼Œ**x264ä¸­ä¸ä¼šæ¯ç¼–ç å®Œä¸€ä¸ªå®å—å°±æ£€æŸ¥ç ç‡çš„æƒ…å†µï¼Œè€Œæ˜¯ä»¥è¡Œä¸ºå•ä½**ã€‚x264ä¸­æ¯ç¼–ç å®Œä¸€è¡Œçš„å®å—ï¼Œå°±ä¼šåˆ¤æ–­åç»­æ‰€æœ‰çš„å®å—ä»¥å½“å‰çš„QPåŸºç¡€å€¼è¿›è¡Œé‡åŒ–æ˜¯å¦ä¼šå‘ç”Ÿè¶…ç¼–ï¼Œå¦‚æœè¶…ç¼–äº†ï¼Œå°±æ˜¯æé«˜å½“å‰çš„QPåŸºç¡€å€¼è¿›è¡Œä¸‹ä¸€è¡Œçš„å®å—ç¼–ç ï¼›åä¹‹å¦‚æœå‘ç”Ÿâ€ç¼–ä¸æ»¡â€œçš„æƒ…å†µåˆ™ä¼šé™ä½å½“å‰çš„QPåŸºç¡€å€¼ï¼›



**æ³¨æ„åªæœ‰å¼€å¯VBVçš„æƒ…å†µä¸‹æ‰ä¼šè¿›è¡Œâ€œè¡Œçº§ç æ§â€**



## æºç åˆ†æ

ç”±äº[å®å—åˆ†æä¹‹å¸§å†…ç¼–ç ](å®å—åˆ†æä¹‹å¸§å†…ç¼–ç .md)ã€[å®å—åˆ†æä¹‹å¸§é—´ç¼–ç ](å®å—åˆ†æä¹‹å¸§é—´ç¼–ç .md)å¯çŸ¥ï¼Œåœ¨è¿›è¡Œå®å—åˆ†æä¹‹å‰éœ€è¦ç¡®å®šå½“å‰å®å—çš„å®å—QP

```c++
// æˆªå–éƒ¨åˆ†ä»£ç 
void x264_macroblock_analyse( x264_t *h )
{
    x264_mb_analysis_t analysis;
    int i_cost = COST_MAX;

    h->mb.i_qp = x264_ratecontrol_mb_qp( h );  // è·å–å½“å‰å®å—çš„å®å—QP
    // ......
}
```



ç”±[å®å—ç¼–ç æµç¨‹åˆ†æ](å®å—ç¼–ç æµç¨‹åˆ†æ.md)å¯çŸ¥ï¼Œåœ¨æ¯ç¼–ç å®Œä¸€ä¸ªå®å—æ—¶éƒ½ä¼šè°ƒç”¨**x264_ratecontrol_mb**è¿›è¡Œç ç‡æ§åˆ¶

```c++
// æˆªå–éƒ¨åˆ†ä»£ç 
static intptr_t slice_write( x264_t *h )
{
    // ....

    // whileå¾ªç¯å¯¹å½“å‰Sliceæ‰€æœ‰å®å—è¿›è¡Œç¼–ç 
    while( 1 )
    {
        /* load cache */
        // åŠ è½½å½“å‰å®å—å‘¨å›´å®å—çš„ä¿¡æ¯
        if( SLICE_MBAFF )
            x264_macroblock_cache_load_interlaced( h, i_mb_x, i_mb_y );
        else
            x264_macroblock_cache_load_progressive( h, i_mb_x, i_mb_y );
		// å®å—åˆ†æ,ç¡®å®šå½“å‰å®å—çš„ç±»å‹(I16x16ã€I8x8ã€I4x4ã€P16x16...)ä»¥åŠå…¶ä»–ä¿¡æ¯(MVç­‰ç­‰)
        x264_macroblock_analyse( h );
        // å®å—ç¼–ç 
        x264_macroblock_encode( h );

        // ä¿å­˜å®å—ä¿¡æ¯
        x264_macroblock_cache_save( h );

        // å®å—ç æ§
        if( x264_ratecontrol_mb( h, mb_size ) < 0 )
        {
            /* å¦‚æœå½“å‰è¡Œå¯¼è‡´å½“å‰è¡Œâ€œç ç‡è¶…ç¼–â€, x264_ratecontrol_mbä¼šè¿”å›<0çš„å€¼
               å¯¹å½“å‰è¡Œçš„æ‰€æœ‰å®å—è¿›è¡Œé‡æ–°åˆ†æç¼–ç  */
            bitstream_restore( h, &bs_bak[BS_BAK_ROW_VBV], &i_skip, 1 );
            h->mb.b_reencode_mb = 1;
            i_mb_x = 0;
            i_mb_y = i_mb_y - SLICE_MBAFF;
            h->mb.i_mb_prev_xy = i_mb_y * h->mb.i_mb_stride - 1;
            h->sh.i_last_mb = orig_last_mb;
            continue;
        }
		// ....
    }
    return 0;
}
```



------

**x264_ratecontrol_mb_qp**

```C++
// æ­¤å‡½æ•°å°±æ˜¯è·å–å®å—çš„QP
int x264_ratecontrol_mb_qp( x264_t *h )
{
    x264_emms();
    float qp = h->rc->qpm; // qpmå°±æ˜¯ä¸Šæ–‡æ‰€è¯´åˆ°çš„å®å—QPåŸºç¡€å€¼ï¼Œåˆå§‹å€¼ç­‰äºå¸§çº§QP
    if( h->param.rc.i_aq_mode )
    {
        // å¦‚æœå¼€å¯äº†AQä¼šé¢å¤–åŠ ä¸Šä¸€ä¸ªåç§»å€¼(AQåŸç†å¯å‚è€ƒAQè‡ªé€‚åº”é‡åŒ–.mdç« èŠ‚)
         /* MB-tree currently doesn't adjust quantizers in unreferenced frames. */
        float qp_offset = h->fdec->b_kept_as_ref ? h->fenc->f_qp_offset[h->mb.i_mb_xy] : h->fenc->f_qp_offset_aq[h->mb.i_mb_xy];
        /* Scale AQ's effect towards zero in emergency mode. */
        if( qp > QP_MAX_SPEC )
            qp_offset *= (QP_MAX - qp) / (QP_MAX - QP_MAX_SPEC);
        qp += qp_offset;
    }
    // é™åˆ¶qpåœ¨i_qp_minå’Œi_qp_maxä¹‹é—´ï¼Œ+0.5æ˜¯ä¸ºäº†å››èˆäº”å…¥
    return x264_clip3( qp + 0.5f, h->param.rc.i_qp_min, h->param.rc.i_qp_max );
}
```





```C++
/* TODO:
 *  eliminate all use of qp in row ratecontrol: make it entirely qscale-based.
 *  make this function stop being needlessly O(N^2)
 *  update more often than once per row? */
int x264_ratecontrol_mb( x264_t *h, int bits )
{
    // å®å‚bitsä¸ºå½“å‰å®å—ç¼–ç åçš„æ¯”ç‰¹å¤§å°
    x264_ratecontrol_t *rc = h->rc;
    const int y = h->mb.i_mb_y;

    h->fdec->i_row_bits[y] += bits; // å­˜å‚¨å½“å‰è¡Œå·²ç¼–ç çš„æ¯”ç‰¹å¤§å°
    rc->qpa_aq += h->mb.i_qp;

    /*
    	å¦‚æœå½“å‰å®å—ä¸æ˜¯å½“å‰è¡Œæœ€åä¸€ä¸ªå®å—åˆ™returnï¼Œæ˜¯çš„è¯æ‰å¾€ä¸‹æ‰§è¡Œ
    	è¿™ä¹Ÿæ˜¯â€œå‰è¨€â€ä¸­è¯´çš„ç¼–ç å®Œä¸€è¡Œåæ‰è¿›è¡Œè°ƒæ§çš„åœ°æ–¹
    */
    if( h->mb.i_mb_x != h->mb.i_mb_width - 1 )
        return 0;

    x264_emms();
    rc->qpa_rc += rc->qpm * h->mb.i_mb_width;

    if( !rc->b_vbv )
        return 0;

    float qscale = qp2qscale( rc->qpm ); // è·å–å½“å‰è¡Œçš„QPåŸºç¡€å€¼qpmï¼Œå¹¶è½¬ä¸ºqscale
    h->fdec->f_row_qp[y] = rc->qpm;     // ä¿å­˜å½“å‰è¡Œçš„åŸºç¡€QPå€¼
    h->fdec->f_row_qscale[y] = qscale;  // ä¿å­˜å½“å‰è¡Œçš„åŸºç¡€QScaleå€¼
	// æ›´æ–°é¢„æµ‹å™¨ï¼Œå…·ä½“ç»†èŠ‚å‚è€ƒâ€œæ¯”ç‰¹é¢„æµ‹å™¨(predictor).mdâ€ç« èŠ‚
    update_predictor( &rc->row_pred[0], qscale, h->fdec->i_row_satd[y], h->fdec->i_row_bits[y] );
    if( h->sh.i_type != SLICE_TYPE_I && rc->qpm < h->fref[0][0]->f_row_qp[y] )
        update_predictor( &rc->row_pred[1], qscale, h->fdec->i_row_satds[0][0][y], h->fdec->i_row_bits[y] );

    /* update ratecontrol per-mbpair in MBAFF */
    if( SLICE_MBAFF && !(y&1) )
        return 0;  // éš”è¡Œç¼–ç æ‰ä¼šè¿›å…¥ï¼Œç°åœ¨å¾ˆå°‘ä½¿ç”¨è¿™ç§ç¼–ç æ–¹å¼äº†ï¼Œä¸»è¦è¿˜æ˜¯ä»¥é€è¡Œç¼–ç ä¸ºä¸»

    /* FIXME: We don't currently support the case where there's a slice
     * boundary in between. */
    // å½“å‰è¡Œæ˜¯å¦å¯ä»¥é‡æ–°ç¼–ç 
    int can_reencode_row = h->sh.i_first_mb <= ((h->mb.i_mb_y - SLICE_MBAFF) * h->mb.i_mb_stride);

    /* tweak quality based on difference from predicted size */
    // ç¡®å®šä¸€äº›å˜é‡å€¼
    float prev_row_qp = h->fdec->f_row_qp[y];   // è·å–å½“å‰è¡Œçš„åŸºç¡€QPå€¼
    float qp_absolute_max = h->param.rc.i_qp_max;
    if( rc->rate_factor_max_increment )
        qp_absolute_max = X264_MIN( qp_absolute_max, rc->qp_novbv + rc->rate_factor_max_increment );
    float qp_max = X264_MIN( prev_row_qp + h->param.rc.i_qp_step, qp_absolute_max );
    float qp_min = X264_MAX( prev_row_qp - h->param.rc.i_qp_step, h->param.rc.i_qp_min );
    float step_size = 0.5f;  // åŸºç¡€QPè°ƒèŠ‚çš„æ­¥é•¿
    // å½“å‰å¸§/Sliceé¢„æµ‹ç¼–ç åçš„å¤§å°
    float slice_size_planned = h->param.b_sliced_threads ? rc->slice_size_planned : rc->frame_size_planned;
    // æˆªè‡³åˆ°å½“å‰è¡Œï¼Œå·²ç¼–ç æ‰€æœ‰å®å—ç”Ÿæˆçš„æ€»æ¯”ç‰¹å¤§å°
    float bits_so_far = row_bits_so_far( h, y );
    float max_frame_error = x264_clip3f( 1.0 / h->mb.i_mb_height, 0.05, 0.25 );
    float max_frame_size = rc->frame_size_maximum - rc->frame_size_maximum * max_frame_error;
    max_frame_size = X264_MIN( max_frame_size, rc->buffer_fill - rc->buffer_rate * max_frame_error );
    float size_of_other_slices = 0;
    if( h->param.b_sliced_threads )
    {
        // å¼€å¯Sliceå¹¶è¡Œçš„æƒ…å†µä¸‹æ‰ä¼šè¿›å…¥åˆ°è¿™é‡Œ
        float size_of_other_slices_planned = 0;
        for( int i = 0; i < h->param.i_threads; i++ )
            if( h != h->thread[i] )
            {
                size_of_other_slices += h->thread[i]->rc->frame_size_estimated;
                size_of_other_slices_planned += h->thread[i]->rc->slice_size_planned;
            }
        float weight = rc->slice_size_planned / rc->frame_size_planned;
        size_of_other_slices = (size_of_other_slices - size_of_other_slices_planned) * weight + size_of_other_slices_planned;
    }
    if( y < h->i_threadslice_end-1 )
    {
        /* B-frames shouldn't use lower QP than their reference frames. */
        if( h->sh.i_type == SLICE_TYPE_B )
        {
            qp_min = X264_MAX( qp_min, X264_MAX( h->fref[0][0]->f_row_qp[y+1], h->fref[1][0]->f_row_qp[y+1] ) );
            rc->qpm = X264_MAX( rc->qpm, qp_min );
        }
		/* buffer_fillä¸ºå½“å‰vbvçš„æ°´é‡(è¿™é‡Œä»¥æ°´é‡å½¢å®¹ï¼Œå…·ä½“å¯å‚è€ƒç ç‡æ§åˆ¶-å¸§çº§ç æ§ç« èŠ‚)
		   frame_size_plannedä¸ºå½“å‰å¸§é¢„æµ‹ç¼–ç åçš„æ¯”ç‰¹å¤§å°ï¼Œåœ¨â€œå¸§çº§ç æ§â€ä¸­ä¼šè®¡ç®—å¾—åˆ°
		   buffer_left_plannedä¸ºé¢„è®¡å½“å‰å¸§ç¼–ç å®Œå‰©ä½™çš„æ°´é‡å¤§å°
		*/
        float buffer_left_planned = rc->buffer_fill - rc->frame_size_planned;
        buffer_left_planned = X264_MAX( buffer_left_planned, 0.f );
        /* More threads means we have to be more cautious in letting ratecontrol use up extra bits. */
        // rc_tolå¯ä»¥ç†è§£ä¸ºè§¦å‘ç ç‡è°ƒèŠ‚çš„ä¸´ç•Œå€¼
        float rc_tol = buffer_left_planned / h->param.i_threads * rc->rate_tolerance;
        // æ ¹æ®å·²ç¼–ç å®å—ç”Ÿæˆçš„æ¯”ç‰¹å¤§å°ä»¥åŠé¢„è®¡åç»­å®å—ç¼–ç çš„æ¯”ç‰¹é¢„æµ‹å¾—åˆ°å½“å‰å¸§ç¼–ç åçš„æ¯”ç‰¹å¤§å°b1
        float b1 = bits_so_far + predict_row_size_to_end( h, y, rc->qpm ) + size_of_other_slices;
        float trust_coeff = x264_clip3f( bits_so_far / slice_size_planned, 0.0, 1.0 );

        /* Don't increase the row QPs until a sufficent amount of the bits of the frame have been processed, in case a flat */
        /* area at the top of the frame was measured inaccurately. */
        if( trust_coeff < 0.05f )
            qp_max = qp_absolute_max = prev_row_qp;

        if( h->sh.i_type != SLICE_TYPE_I )
            rc_tol *= 0.5f;

        if( !rc->b_vbv_min_rate )
            qp_min = X264_MAX( qp_min, rc->qp_novbv );
		
        while( rc->qpm < qp_max
               && ((b1 > rc->frame_size_planned + rc_tol) ||
                   (b1 > rc->frame_size_planned && rc->qpm < rc->qp_novbv) ||
                   (b1 > rc->buffer_fill - buffer_left_planned * 0.5f)) )
        {
            // å¦‚æœæ»¡è¶³whileçš„æ¡ä»¶ï¼Œå¯ä»¥è®¤ä¸ºå®¹æ˜“å‘ç”Ÿâ€œè¶…ç¼–â€ç°è±¡ï¼Œä¸Šè°ƒåŸºç¡€çš„QPå€¼(rc->qpm)
            rc->qpm += step_size;
            b1 = bits_so_far + predict_row_size_to_end( h, y, rc->qpm ) + size_of_other_slices;
        }

        float b_max = b1 + ((rc->buffer_fill - rc->buffer_size + rc->buffer_rate) * 0.90f - b1) * trust_coeff;
        rc->qpm -= step_size;
        float b2 = bits_so_far + predict_row_size_to_end( h, y, rc->qpm ) + size_of_other_slices;
        while( rc->qpm > qp_min && rc->qpm < prev_row_qp
               && (rc->qpm > h->fdec->f_row_qp[0] || rc->single_frame_vbv)
               && (b2 < max_frame_size)
               && ((b2 < rc->frame_size_planned * 0.8f) || (b2 < b_max)) )
        {
            // å¦‚æœæ»¡è¶³whileæ¡ä»¶ï¼Œå¯ä»¥è®¤ä¸ºå®¹æ˜“å‘ç”Ÿâ€œç¼–ä¸æ»¡â€ç°è±¡ï¼Œä¸‹è°ƒåŸºç¡€çš„QPå€¼(rc->qpm)
            b1 = b2;
            rc->qpm -= step_size;
            b2 = bits_so_far + predict_row_size_to_end( h, y, rc->qpm ) + size_of_other_slices;
        }
        rc->qpm += step_size;

        /* avoid VBV underflow or MinCR violation */
        while( rc->qpm < qp_absolute_max && (b1 > max_frame_size) )
        {
            // é¿å…å‘ç”Ÿvbvä¸‹æº¢æˆ–è€…MinCR,å†ä»¥å¯¹qpmåšè°ƒæ§
            rc->qpm += step_size;
            b1 = bits_so_far + predict_row_size_to_end( h, y, rc->qpm ) + size_of_other_slices;
        }

        rc->frame_size_estimated = b1 - size_of_other_slices;

        /* If the current row was large enough to cause a large QP jump, try re-encoding it. */
        if( rc->qpm > qp_max && prev_row_qp < qp_max && can_reencode_row )
        {
            /* å¦‚æœåŸºç¡€QPå€¼qpmè°ƒèŠ‚å®Œå‘ç°å¤§äºqp_maxï¼Œä¸”ç¼–ç å½“å‰è¡Œæ—¶çš„åŸºç¡€QPå°äºqp_max
               åˆ™å¯ä»¥è®¤ä¸ºå½“å‰è¡Œçš„ç¼–ç ç ç‡æ¯”è¾ƒé«˜ï¼Œéœ€è¦å¯¹å½“å‰è¡Œè¿›è¡Œé‡æ–°ç¼–ç 
            */
            /* Bump QP to halfway in between... close enough. */
            // é€‚å½“è°ƒé«˜å½“å‰è¡Œçš„åŸºç¡€QPå€¼
            rc->qpm = x264_clip3f( (prev_row_qp + rc->qpm)*0.5f, prev_row_qp + 1.0f, qp_max );
            rc->qpa_rc = rc->qpa_rc_prev;
            rc->qpa_aq = rc->qpa_aq_prev;
            h->fdec->i_row_bits[y] = 0;
            h->fdec->i_row_bits[y-SLICE_MBAFF] = 0;
            return -1;
        }
    }
    else
    {
        rc->frame_size_estimated = bits_so_far;

        /* Last-ditch attempt: if the last row of the frame underflowed the VBV,
         * try again. */
        if( rc->qpm < qp_max && can_reencode_row
            && (bits_so_far + size_of_other_slices > X264_MIN( rc->frame_size_maximum, rc->buffer_fill )) )
        {
            // å¦‚æœæ˜¯æœ€åä¸€è¡Œï¼Œå‘ç°ç ç‡è¶…è¿‡äº†buffer_fill(å³å‘ç”ŸVBVä¸‹æº¢å‡º)ï¼Œä¹Ÿä¼šå¯¹å½“å‰è¡Œè¿›è¡Œé‡æ–°ç¼–ç 
            rc->qpm = qp_max;
            rc->qpa_rc = rc->qpa_rc_prev;
            rc->qpa_aq = rc->qpa_aq_prev;
            h->fdec->i_row_bits[y] = 0;
            h->fdec->i_row_bits[y-SLICE_MBAFF] = 0;
            return -1;
        }
    }

    rc->qpa_rc_prev = rc->qpa_rc;
    rc->qpa_aq_prev = rc->qpa_aq;

    return 0;
}
```



## æ€»ç»“

ç»¼ä¸Šå¯ä»¥çœ‹å‡ºï¼Œç»è¿‡å¸§çº§ç æ§ä¼šç¡®å®šä¸€ä¸ªå¸§çº§QPï¼ŒåŒæ—¶ä¼šç¡®å®šå®å—åŸºç¡€QPå€¼(ç­‰äºå¸§çº§QP)qpmï¼Œåœ¨å¯¹æŸè¡Œå®å—è¿›è¡Œç¼–ç æ—¶ä¼šä¾æ®qpm+AQå¾—åˆ°çš„å€¼ä½œä¸ºå½“å‰å®å—çš„QPã€‚ 

æ¯ç¼–ç å®Œä¸€è¡Œå®å—ï¼Œä¼šè¿›è¡Œç ç‡çš„æ£€æµ‹ï¼Œå¦‚æœå‘ç°å¿«â€œè¶…ç¼–â€äº†ï¼Œä¼šè°ƒé«˜qpmï¼›åä¹‹å¦‚æœå‘ç°â€œç¼–ä¸æ»¡â€ åˆ™ä¼šè°ƒä½qpmï¼›   

åŒæ—¶å¦‚æœè°ƒèŠ‚å®Œqpmä¹‹åä¾æ—§å‘ç°å¯èƒ½ä¼šâ€œè¶…ç¼–â€ï¼Œå¯èƒ½ä¼šå¯¹å½“å‰è¡Œå®å—è¿›è¡Œé‡ç¼–ç æ“ä½œã€‚





**reference**ï¼š

ğŸ±â€ğŸhttps://github.com/mirror/x264

ğŸ±â€ğŸhttps://zhuanlan.zhihu.com/p/477766087