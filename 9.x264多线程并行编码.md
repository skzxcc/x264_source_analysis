# å‰è¨€

**æ‰€è°“å¹¶è¡Œç¼–ç å°±æ˜¯å¤šä¸ªçº¿ç¨‹åŒæ—¶ç¼–ç ï¼Œç›®çš„æ˜¯ä¸ºäº†é™ä½å•å¸§å¹³å‡çš„ç¼–ç æ—¶é—´**ã€‚

éšç€æ—¶ä»£çš„è¿›æ­¥ï¼Œè§†é¢‘ç¼–ç æ ‡å‡†ä¹Ÿä¸€ç›´ä¸æ–­çš„åˆ›æ–°ï¼Œç”¨ä»¥æ»¡è¶³å½“å‰ä»¥åŠæœªæ¥ä¸€æ®µæ—¶é—´çš„éœ€æ±‚ã€‚ä»H261ï¼ŒH262ï¼ŒH263ï¼ŒH263+ï¼ŒH264å†åˆ°åæ¥çš„H265ï¼ŒH266ã€‚ä»H264åˆ°H266ï¼Œæ¯ä¸€ä¸ªæ–°æ ‡å‡†éƒ½èƒ½åœ¨ä¸Šä¸€æ ‡å‡†çš„åŸºç¡€ä¸Šå†æå‡30~50%çš„å‹ç¼©ç‡ï¼Œç„¶è€Œå‹ç¼©ç‡çš„æå‡æ˜¯å»ºç«‹åœ¨åŠ å¤§è®¡ç®—é‡çš„åŸºç¡€ä¹‹ä¸Šçš„ã€‚è¿™å°±æ˜¯æˆ‘ä»¬å¸¸è¯´çš„â€œ**ä»¥æ—¶é—´æ¢ç©ºé—´**â€

ä¸ºäº†èƒ½å¤Ÿé™ä½å•å¸§çš„å¹³å‡ç¼–ç æ—¶é—´ï¼Œx264æ˜¯èƒ½å¤Ÿæ”¯æŒå¤šçº¿ç¨‹å¹¶è¡Œç¼–ç çš„ï¼›å¯ä»¥åˆ†ä¸º**å¸§çº§å¹¶è¡Œ**å’Œ**ç‰‡çº§å¹¶è¡Œ**ä¸¤ç§æ–¹å¼



ä¸‹é¢æ˜¯x264æä¾›çš„æ–‡æ¡£ï¼Œæ­¤å¤„è´´å‡ºå…¶ä¸­ä¸€éƒ¨åˆ†å†…å®¹  https://github.com/mirror/x264/blob/master/doc/threads.txt

```tex
Historical notes:
Slice-based threads was the original threading model of x264.  It was replaced with frame-based threads in r607.  This document was originally written at that time.  Slice-based threading was brought back (as an optional mode) in r1364 for low-latency encoding.  Furthermore, frame-based threading was modified significantly in r1246, with the addition of threaded lookahead.

Old threading method: slice-based
application calls x264
x264 runs B-adapt and ratecontrol (serial)
split frame into several slices, and spawn a thread for each slice
wait until all threads are done
deblock and hpel filter (serial)
return to application
In x264cli, there is one additional thread to decode the input.

New threading method: frame-based
application calls x264
x264 requests a frame from lookahead, which runs B-adapt and ratecontrol parallel to the current thread, separated by a buffer of size sync-lookahead
spawn a thread for this frame
thread runs encode, deblock, hpel filter
meanwhile x264 waits for the oldest thread to finish
return to application, but the rest of the threads continue running in the background
No additional threads are needed to decode the input, unless decoding is slower than slice+deblock+hpel, in which case an additional input thread would allow decoding in parallel.

Penalties for slice-based threading:
Each slice adds some bitrate (or equivalently reduces quality), for a variety of reasons: the slice header costs some bits, cabac contexts are reset, mvs and intra samples can't be predicted across the slice boundary.
In CBR mode, multiple slices encode simultaneously, thus increasing the maximum misprediction possible with VBV.
Some parts of the encoder are serial, so it doesn't scale well with lots of cpus.
```

å¤§æ¦‚æ„æ€å°±æ˜¯x264æ”¯æŒåŸºäºå¸§çš„å¤šçº¿ç¨‹å’ŒåŸºäºSliceçš„å¤šçº¿ç¨‹(ä¹Ÿå°±æ˜¯ä¸Šé¢è¯´çš„å¸§çº§å¹¶è¡Œå’Œç‰‡çº§å¹¶è¡Œ)ï¼Œä¸”å¸§çº§å¹¶è¡Œç›®å‰ä½œä¸ºx264æœ€æ–°çš„å¹¶è¡Œç¼–ç æ–¹å¼ï¼ŒåŒæ—¶ä¾æ—§ä¿ç•™ç‰‡çº§å¹¶è¡Œçš„åŠŸèƒ½(ç”¨ä»¥å®ç°ä½å»¶è¿Ÿç¼–ç )

- **å¤šä¸ªSliceå¯ä»¥è®¤ä¸ºå°±æ˜¯å°†ä¸€å¸§å®Œæ•´çš„å›¾åƒåˆ†ä¸ºäº’ä¸é‡å çš„å‡ å¼ å°å›¾ï¼Œæ¯ä¸ªå°å›¾å°±æ˜¯ä¸€ä¸ªSliceï¼Œæ‰€è°“ç‰‡çº§å¹¶è¡Œï¼Œå³å¯¹å¤šä¸ªSliceåŒæ—¶ç¼–ç **
- **æ‰€è°“å¸§çº§å¹¶è¡Œå°±æ˜¯åŒæ—¶å¯¹å¤šä¸ªå®Œæ•´çš„å›¾åƒè¿›è¡Œç¼–ç **

*é—æ†¾çš„æ˜¯x264ä¸æ”¯æŒåŒæ—¶å¼€å¯å¸§çº§å¹¶è¡Œå’ŒSliceçº§å¹¶è¡Œï¼Œå½“ç„¶è¿™ä»æŠ€æœ¯ä¸Šæ˜¯å¯ä»¥å®ç°çš„*



#### å¦‚ä½•å¼€å¯å¹¶è¡Œç¼–ç ï¼Ÿ

ç»“åˆ[x264çš„ä½¿ç”¨](1.x264çš„ä½¿ç”¨.md) ç« èŠ‚ï¼Œåœ¨åˆ›å»ºç¼–ç å™¨çš„ä½¿ç”¨ä¼šé…ç½®ç¼–ç å‚æ•°x264_param_t

```c++
x264_param_t param;
param.i_threads = 4;  // å¼€å¯4ä¸ªçº¿ç¨‹
param.b_sliced_threads = 0;  // å¦‚æœb_sliced_threadsç­‰äº0è¡¨ç¤ºä½¿ç”¨å¸§çº§å¹¶è¡Œï¼Œ å¦åˆ™ä½¿ç”¨Sliceå¹¶è¡Œ
```



## ç‰‡çº§å¹¶è¡Œ(Slice)

å¯¹äºå¸§å†…å®å—åœ¨è¿›è¡Œç¼–ç æ—¶æ˜¯éœ€è¦ä¾èµ–å‘¨å›´å®å—é‡å»ºåçš„åƒç´ ç‚¹ï¼Œè€Œå¯¹äºå¸§é—´å®å—åœ¨è¿›è¡Œè¿åŠ¨æœç´¢æ—¶ä¹Ÿéœ€è¦é€šè¿‡å‘¨å›´å®å—çš„è¿åŠ¨çŸ¢é‡å¾—åˆ°é¢„æµ‹è¿åŠ¨çŸ¢é‡ï¼›å› æ­¤å¯ä»¥çœ‹å‡ºæ¥ï¼Œä¸ç®¡æ˜¯å¸§å†…å®å—è¿˜æ˜¯å¸§é—´å®å—éƒ½è¦åœ¨å‘¨å›´(ä¸Šæ–¹å®å—å’Œå·¦æ–¹å®å—)å·²ç»ç¼–ç å®Œæ‰èƒ½è¿›è¡Œç¼–ç ï¼Œè¿™æ ·ä¸€å¸§å›¾åƒå¥½åƒåªèƒ½â€œ**ä»å·¦å¾€å³ï¼Œä»ä¸Šå¾€ä¸‹**â€çš„æ–¹å¼é€æ­¥è¿›è¡Œç¼–ç ï¼Œ**ä¼¼ä¹æ— æ³•åšåˆ°å¹¶è¡Œç¼–ç ï¼**

> è¿™é‡Œç®€å•ä»‹ç»ä¸‹Slice
>
> å½“æ—¶H264æ ‡å‡†è®¾è®¡Sliceçš„ä¸»è¦ç›®çš„æ˜¯ä¸ºäº†é˜²æ­¢è¯¯ç æ‰©æ•£ï¼Œä¸€å¼ å›¾åƒå¯ä»¥åˆ†ä¸º1~Nä¸ªSliceï¼ŒSliceå¯ä»¥ç†è§£ä¸ºâ€œå°å›¾â€ï¼›
>
> å°†ä¸€å¼ å›¾åƒåœ¨ç©ºé—´ä¸Šåˆ’åˆ†ä¸º1~Nå¼ å°å›¾ï¼Œå„ä¸ªSliceä¸ä¾èµ–å…¶ä»–Sliceï¼Œèƒ½å¤Ÿå•ç‹¬ç¼–ç å•ç‹¬è§£ç ï¼›
>
> å‡å¦‚ä¸€å¼ å›¾ç‰‡åˆ†ä¸º4ä¸ªSliceè¿›è¡Œç¼–ç ï¼Œåœ¨ä¼ è¾“æ—¶ç”±äºç½‘ç»œä¸¢åŒ…ï¼Œæ¥æ”¶ç«¯åªæ”¶åˆ°å…¶ä¸­ä¸¤ä¸ªSliceï¼Œè¿™æ ·è¿™ä¸¤ä¸ªSliceä¹Ÿæ˜¯èƒ½å¤Ÿæ­£å¸¸è§£ç ã€‚



**æ­£æ˜¯ç”±äºSliceä¹‹é—´çš„ç‹¬ç«‹æ€§ï¼Œä¹Ÿä¸ºå¹¶è¡Œå¤„ç†æä¾›äº†æ€è·¯ã€‚**ä¾‹å¦‚å°†ä¸€å¸§å›¾åƒåˆ†ä¸º4ä¸ªSliceï¼Œç”±äºå„ä¸ªSliceä¹‹é—´ä¸äº’ç›¸ä¾èµ–ï¼Œæ‰€ä»¥å¯ä»¥å¼€å¯å››ä¸ªçº¿ç¨‹å¯¹è¿™4ä¸ªSliceåŒæ—¶ç¼–ç ï¼Œä»è€Œé™ä½å•å¸§çš„ç¼–ç æ—¶é—´



åˆ†å¤šSliceç¼–ç æœ‰ä¼˜ç‚¹ä¹Ÿæœ‰ç¼ºç‚¹ï¼Œè¿™é‡Œåšä¸ªåˆ†æ

**ä¼˜ç‚¹ï¼š**

- èƒ½å¤Ÿå¹¶è¡Œå¤„ç†ï¼Œ**é™ä½å•å¸§çš„ç¼–ç æ—¶é—´**
- æ›´å¼ºçš„ç½‘ç»œé€‚åº”æ€§(ä¸¢å¼ƒæŸä¸ªSliceä¸å½±å“å…¶ä»–Sliceçš„è§£ç )

**ç¼ºç‚¹ï¼š**

- ç¼–ç è´¨é‡ä¼šæ›´å·®ä¸€ç‚¹(å› ä¸ºå¤šSliceä¼šç‰ºç‰²ä¸€å®šç©ºé—´ä¸Šçš„ç›¸å…³æ€§ï¼Œä¸”ä¸åŒSliceä¹‹å‰çš„è¾¹ç•Œæ— æ³•è¿›è¡Œæ»¤æ³¢)

<u>è¿˜æœ‰ä¸€ç‚¹ä¸çŸ¥é“ç®—ä¸ç®—ä¼˜ç‚¹</u>ï¼šä¸€äº›æ—§è®¾å¤‡ä¸Šåªæ”¯æŒSingleNaluçš„RTPä¼ è¾“ï¼Œå³ä¸€ä¸ªRTPåŒ…å«ä¸€ä¸ªå®Œæ•´çš„Nalu(Slice)ï¼Œç”±äºå—åˆ°MTUçš„é™åˆ¶ä¸€èˆ¬RTPåŒ…çš„å¤§å°éƒ½ä¼šå°äº1500å­—èŠ‚ï¼Œæ­£å¸¸æƒ…å†µä¸‹å¦‚æœç¼–ç å™¨ä½¿ç”¨å•Sliceç¼–ç ï¼Œç¼–ç åçš„ç æµå¤§å°ä¸€èˆ¬éƒ½ä¼šå¤§äºè¿™ä¸ªæ•°ï¼Œæ‰€ä»¥è¿™ç§æƒ…å†µä¸‹ç¼–ç å™¨åªèƒ½ä½¿ç”¨å¤šSliceç¼–ç  (*å…·ä½“çš„RTP payload H264çš„ç»†èŠ‚å¯ä»¥è‡ªè¡Œç™¾åº¦*)







## å¸§çº§å¹¶è¡Œ

ç”±äºSliceå¹¶è¡Œä¼šç‰ºç‰²ä¸åŒSliceä¹‹é—´çš„ç©ºé—´ä¸Šçš„ç›¸å…³æ€§ï¼Œå¯¼è‡´ç¼–ç è´¨é‡ä¼šæ›´ä½ä¸€ä¸‹ã€‚å¯èƒ½æ­£æ˜¯å‡ºäºè¿™ä¸ªè€ƒè™‘x264æ‰å¼•å…¥äº†å¸§çº§å¹¶è¡Œï¼Œå¸§çº§å¹¶è¡Œè¿˜æ˜¯é’ˆå¯¹ä¸€å¸§å®Œæ•´çš„å¸§è¿›è¡Œç¼–ç ï¼Œä¸ä¼šåˆ’åˆ†ä¸ºå¤šä¸ªSliceï¼Œæ‰€ä»¥ä¸å­˜åœ¨ä¸Šè¿°å¯¼è‡´ç¼–ç è´¨é‡æ›´ä½ä¸‹çš„å¼Šç«¯ã€‚



æˆ‘ä»¬çŸ¥é“H264çš„å¸§é—´ç¼–ç ï¼Œå½“å‰å¾…ç¼–ç å¸§æ˜¯éœ€è¦ä¾èµ–ä¹‹å‰å·²ç»ç¼–ç å®Œæˆçš„å¸§ï¼Œæ‰€ä»¥ä¼¼ä¹ä¹Ÿ**æ— æ³•åšåˆ°å¤šä¸ªå¸§åŒæ—¶è¿›è¡Œç¼–ç ï¼Ÿ**

å…¶å®ä¸ç„¶ï¼Œä»”ç»†æƒ³æƒ³å¯ä»¥å‘ç°ï¼Œç¼–ç å½“å‰å¸§çš„æŸä¸€è¡Œå®å—æ—¶ï¼Œåœ¨è¿›è¡Œè¿åŠ¨æœç´¢æ˜¯å¦éœ€è¦æœç´¢å‚è€ƒå¸§çš„æ•´å¼ å›¾åƒå‘¢ï¼Ÿç­”æ¡ˆè‚¯å®šæ˜¯ä¸éœ€è¦çš„ã€‚ä¾‹å¦‚Pic_0å·²ç»ç¼–ç å®Œå‰20è¡Œçš„å®å—æ—¶ï¼ŒPic_1çš„ç¬¬ä¸€è¡Œå®å—å°±å¯ä»¥å¼€å§‹ç¼–ç äº†(*å› ä¸ºPic_0ç¬¬ä¸€è¡Œå®å—åœ¨è¿›è¡Œå¸§é—´è¿åŠ¨æœç´¢æ—¶æ˜¯ä¸éœ€è¦æœç´¢åˆ°Pic_0ä¸­ç¬¬20è¡Œä¹‹åçš„å®å—*)ï¼Œ å½“Pic_1ç¼–ç åˆ°ç¬¬10è¡Œæ—¶ï¼ŒPic_0åªç¼–ç åˆ°ç¬¬29è¡Œï¼Œæ­¤æ—¶Pic_1è¿›è¡Œé˜»å¡ç­‰å¾…ï¼Œå¾…Pic_0ç¼–ç å®Œç¬¬30è¡Œæ—¶å†é€šçŸ¥Pic_1ï¼Œä¸¤å¸§å†åŒæ—¶è¿›è¡Œç¼–ç ï¼Œ è™½ç„¶æ˜¯åŒæ—¶ç¼–ç ä½†ç”±äºä¾èµ–æ€§Pic_1ä¸€å®šä¼šæ…¢äºPic_0å®Œæˆç¼–ç ã€‚  åŒç†Pic_2ä¹Ÿå¯ä»¥åœ¨Pic_1ç¼–ç å®Œä¸€å®šè¡Œæ•°ä¹‹åä¹Ÿå¼€å¯ç¼–ç ......

**è¿™ä¸ªâ€œ20è¡Œâ€çš„é—´éš”åªæ˜¯ä¸ªå‡è®¾å€¼ï¼Œç†è®ºä¸Šè¿™ä¸ªå€¼è¶Šå°å¹¶è¡Œç¨‹åº¦è¶Šé«˜ï¼Œä½†è¿åŠ¨æœç´¢çš„èŒƒå›´ä¹Ÿä¼šè¶Šå°ï¼Œç†è®ºä¸Šè´¨é‡ä¼šæ›´ä½ä¸€ç‚¹**(*ä½†å¦‚æœè¿™ä¸ªè¡Œæ•°é—´éš”è®¾ç½®åˆç†çš„è¯åŸºæœ¬æ˜¯ä¸ä¼šå½±å“ç¼–ç è´¨é‡çš„*)



**å›¾ç¤ºï¼š**

![](9.x264å¤šçº¿ç¨‹å¹¶è¡Œç¼–ç .assets/å¸§çº§å¹¶è¡Œæµç¨‹å›¾ä¸€.png)

![](9.x264å¤šçº¿ç¨‹å¹¶è¡Œç¼–ç .assets/å¸§çº§å¹¶è¡Œæµç¨‹å›¾äºŒ.png)

![](9.x264å¤šçº¿ç¨‹å¹¶è¡Œç¼–ç .assets/å¸§çº§å¹¶è¡Œæµç¨‹å›¾ä¸‰.png)

![](9.x264å¤šçº¿ç¨‹å¹¶è¡Œç¼–ç .assets/å¸§çº§å¹¶è¡Œæµç¨‹å›¾å››.png)





å¸§çº§å¹¶è¡Œç¼–ç æœ‰ä¼˜ç‚¹ä¹Ÿæœ‰ç¼ºç‚¹ï¼Œè¿™é‡Œåšä¸ªåˆ†æ

**ä¼˜ç‚¹ï¼š**

- å¹¶è¡Œç¼–ç ï¼Œ**é™ä½æ€»çš„ç¼–ç æ—¶é—´**(è¿™ä¸ªä¸Sliceä¸åŒï¼ŒSliceå¹¶è¡Œæ˜¯é™ä½å•å¸§çš„ç¼–ç æ—¶é—´(*å½“ç„¶è¿™ä¹Ÿæ˜¯é™ä½æ€»ç¼–ç æ—¶é—´*)ï¼Œè€Œå¸§çº§å¹¶è¡Œæ˜¯é™ä½æ€»çš„ç¼–ç æ—¶é—´ï¼Œ ç†è®ºä¸Šæ˜¯ä¸ä¼šé™ä½å•å¸§çš„ç¼–ç æ—¶é—´çš„)
- ä¸ä¼šæˆªæ–­å›¾åƒç©ºé—´ä¸Šçš„ç›¸å…³æ€§ï¼Œç†è®ºä¸Šå¯¹æ¯”å•çº¿ç¨‹ä¸ä¼šæœ‰è´¨é‡ä¸‹é™çš„é—®é¢˜

**ç¼ºç‚¹ï¼š**

- **å»¶è¿Ÿè¾“å‡ºï¼Œå¼€å¯Nä¸ªçº¿ç¨‹ä¼šå»¶è¿ŸN-1å¸§è¾“å‡º**(å½“å‰æŠ€æœ¯ä¸Šæ˜¯å¯ä»¥å®ç°ä¸å»¶è¿Ÿè¾“å‡ºçš„ï¼Œä½†x264ä¸­æ²¡è¿™ä¹ˆåš)
- æ›´é«˜çš„å†…å­˜å ç”¨







## æºç åˆ†æ



### å¤šçº¿ç¨‹åˆå§‹åŒ–æºç åˆ†æ

å¼€å¯å¤šçº¿ç¨‹æ—¶ï¼Œåœ¨åˆ›å»ºç¼–ç å™¨x264_encoder_openä¼šè¿›è¡Œä¸€äº›çº¿ç¨‹ç›¸å…³èµ„æºçš„åˆå§‹åŒ–

```c++
// è¿™é‡Œæˆªå–éƒ¨åˆ†ä»£ç 

#if HAVE_THREAD
static void encoder_thread_init( x264_t *h )
{
    // è®¾ç½®çº¿ç¨‹ä¼˜å…ˆçº§
    if( h->param.i_sync_lookahead )
        x264_lower_thread_priority( 10 );
}
#endif

x264_t *x264_encoder_open( x264_param_t *param )
{
    // ......
    
    // çº¿ç¨‹åˆå§‹åŒ–ï¼Œè¿™æ˜¯ä¸ªé‡ç‚¹å‡½æ•°!!!
    if( h->param.i_threads > 1 &&
        x264_threadpool_init( &h->threadpool, h->param.i_threads, (void*)encoder_thread_init, h ) )
        goto fail;
    
    // h->param.i_threadsä¸ºå½“å‰çš„çº¿ç¨‹æ•°
    for( int i = 0; i < h->param.i_threads; i++ )
    {
        int init_nal_count = h->param.i_slice_count + 3;
        /*
        	allocate_threadlocal_dataè¡¨ç¤ºæ˜¯å¦éœ€è¦alloc
        	å¯¹äºSliceå¹¶è¡Œ(b_sliced_threadsä¸º1)æ˜¯ä¸éœ€è¦é¢å¤–åœ¨åˆ†é…çš„ï¼Œè€Œå¸§çº§å¹¶è¡Œå°±éœ€è¦å¤šåˆ†é…å†…å­˜
        	æ‰€ä»¥å¼€å¯å¸§çº§å¹¶è¡Œä¼šæ¯”Sliceå¹¶è¡Œä¼šæœ‰æ›´é«˜çš„å†…å­˜å ç”¨
         */
        int allocate_threadlocal_data = !h->param.b_sliced_threads || !i;
        if( i > 0 )
            *h->thread[i] = *h;
		// åˆå§‹åŒ–mutexã€condç­‰èµ„æº
        if( x264_pthread_mutex_init( &h->thread[i]->mutex, NULL ) )
            goto fail;
        if( x264_pthread_cond_init( &h->thread[i]->cv, NULL ) )
            goto fail;
		
        if( allocate_threadlocal_data )
        {
            // åˆ›å»ºx264_frame_t
            h->thread[i]->fdec = x264_frame_pop_unused( h, 1 );
            if( !h->thread[i]->fdec )
                goto fail;
        }
        else
            h->thread[i]->fdec = h->thread[0]->fdec;
		// ç”³è¯·ç”¨æ¥å­˜å‚¨ç¼–ç åç æµçš„å†…å­˜ç©ºé—´
        CHECKED_MALLOC( h->thread[i]->out.p_bitstream, h->out.i_bitstream );
        /* Start each thread with room for init_nal_count NAL units; it'll realloc later if needed. */
        CHECKED_MALLOC( h->thread[i]->out.nal, init_nal_count*sizeof(x264_nal_t) );
        h->thread[i]->out.i_nals_allocated = init_nal_count;

        if( allocate_threadlocal_data && x264_macroblock_cache_allocate( h->thread[i] ) < 0 )
            goto fail;
    }
}
```



**x264_threadpool_init**

```c++
int x264_threadpool_init( x264_threadpool_t **p_pool, int threads,
                          void (*init_func)(void *), void *init_arg )
{
    if( threads <= 0 )
        return -1;

    if( x264_threading_init() < 0 )
        return -1;
	// åˆ›å»ºçº¿ç¨‹æ± 
    x264_threadpool_t *pool;
    CHECKED_MALLOCZERO( pool, sizeof(x264_threadpool_t) );
    *p_pool = pool;

    pool->init_func = init_func;
    pool->init_arg  = init_arg;
    pool->threads   = threads;

    CHECKED_MALLOC( pool->thread_handle, pool->threads * sizeof(x264_pthread_t) );
	
    /*
    	åˆå§‹åŒ–çº¿ç¨‹ç›¸å…³ä»»åŠ¡é˜Ÿåˆ—
    	uninit: list of jobs that are awaiting use
    	run: list of jobs that are queued for processing by the pool
    	done: list of jobs that have finished processing
     */
    if( x264_sync_frame_list_init( &pool->uninit, pool->threads ) ||
        x264_sync_frame_list_init( &pool->run, pool->threads ) ||
        x264_sync_frame_list_init( &pool->done, pool->threads ) )
        goto fail;

    for( int i = 0; i < pool->threads; i++ )
    {
       x264_threadpool_job_t *job;
       CHECKED_MALLOC( job, sizeof(x264_threadpool_job_t) );
       x264_sync_frame_list_push( &pool->uninit, (void*)job );
    }
    // åˆ›å»ºpool->threadsä¸ªçº¿ç¨‹ï¼Œæ¯ä¸ªçº¿ç¨‹éƒ½æ‰§è¡Œå‡½æ•°threadpool_thread
    for( int i = 0; i < pool->threads; i++ )
        if( x264_pthread_create( pool->thread_handle+i, NULL, (void*)threadpool_thread, pool ) )
            goto fail;

    return 0;
fail:
    return -1;
}
```



**threadpool_thread**

```c++
static void *threadpool_thread( x264_threadpool_t *pool )
{
    return (void*)x264_stack_align( threadpool_thread_internal, pool );
}

static void *threadpool_thread_internal( x264_threadpool_t *pool )
{
    if( pool->init_func )
        pool->init_func( pool->init_arg );  // æ‰§è¡Œä¸Šé¢ä¼ ä¸‹æ¥çš„å‡½æ•°æŒ‡é’ˆï¼Œå³è®¾ç½®çº¿ç¨‹ä¼˜å…ˆçº§

    /* å¾ªç¯ä»runé˜Ÿåˆ—ä¸­è·å–jobæ‰§è¡Œï¼Œæ‰§è¡Œå®Œæˆä¹‹åæ”¾åˆ°doneé˜Ÿåˆ—ä¸­å» */
    while( !pool->exit )
    {
        x264_threadpool_job_t *job = NULL;
        x264_pthread_mutex_lock( &pool->run.mutex );
        while( !pool->exit && !pool->run.i_size )
            x264_pthread_cond_wait( &pool->run.cv_fill, &pool->run.mutex );
        if( pool->run.i_size )
        {
            job = (void*)x264_frame_shift( pool->run.list );
            pool->run.i_size--;
        }
        x264_pthread_mutex_unlock( &pool->run.mutex );
        if( !job )
            continue;
        // æ‰§è¡Œfuncå‡½æ•°ï¼Œæ­¤å‡½æ•°ä¸ºä¸ºç¼–ç å‡½æ•°
        job->ret = job->func( job->arg );
        // ç¼–ç å®Œæˆä¹‹åæ”¾åˆ°doneé˜Ÿåˆ—ä¸­å»ï¼Œç­‰å¾…è¾“å‡º
        x264_sync_frame_list_push( &pool->done, (void*)job );
    }
    return NULL;
}

```



#### å°ç»“

å¼€å¯å¤šçº¿ç¨‹æ—¶ï¼Œä¼šåˆ›å»ºå¤šä¸ªçº¿ç¨‹ï¼Œæ¯ä¸ªçº¿ç¨‹éƒ½ä¼šä»ä»»åŠ¡é˜Ÿåˆ—runä¸­å–jobï¼Œç„¶åè¿›è¡Œç¼–ç ï¼Œç¼–ç å®Œæˆä¹‹åPushåˆ°doneé˜Ÿåˆ—ä¸­ç­‰å¾…è¾“å‡ºã€‚ æ‰€ä»¥ä¸ç®¡æ˜¯Sliceå¹¶è¡Œè¿˜æ˜¯å¸§çº§å¹¶è¡Œï¼Œéƒ½æ˜¯å°†å½“å‰çš„Slice/Frameç¼–ç ä»»åŠ¡æ”¾åˆ°runé˜Ÿåˆ—ä¸­å³å¯



------



### ç¼–ç è¿‡ç¨‹æºç åˆ†æ

```c++
// æˆªå–éƒ¨åˆ†ä»£ç 
int  x264_encoder_encode( x264_t *h,
                             x264_nal_t **pp_nal, int *pi_nal,
                             x264_picture_t *pic_in,
                             x264_picture_t *pic_out )
{
    /*
    	thread_currentä¸ºå½“å‰å¸§çš„ä¸Šä¸‹æ–‡x264_t
    	thread_prevä¸ºä¸Šä¸€å¸§çš„ä¸Šä¸‹æ–‡
    	thread_oldestä¸ºæœ€æ—©çš„å¸§çš„ä¸Šä¸‹æ–‡
    	å¦‚æœéå¸§çº§å¹¶è¡Œè¿™ä¸‰ä¸ªå˜é‡æ˜¯æŒ‡å‘åŒä¸€ä¸ªä¸Šä¸‹æ–‡çš„
    */
    x264_t *thread_current, *thread_prev, *thread_oldest;
    if( h->i_thread_frames > 1 )  // å¸§çº§å¹¶è¡Œçš„æ—¶å€™h->i_thread_framesæ‰ä¼šå¤§äº1
    {
        /*
        	å¤šä¸åŒä¸Šä¸‹æ–‡ä¹‹é—´çš„çŠ¶æ€ã€ç æ§åŒæ­¥
        	h->threadä¿å­˜ç€å¤šä¸ªçº¿ç¨‹çš„ä¸Šä¸‹æ–‡ï¼Œä¾‹å¦‚å¼€å¯å››ä¸ªçº¿ç¨‹ï¼Œåˆ™å››ä¸ªx264_tåˆ†åˆ«ä¿å­˜åœ¨h->thread[0]ã€h->thread[1]ã€h->thread[2]ã€h->thread[3]ä¸­
        	å…¶ä¸­h->thread[0]ä¸è¿™é‡Œçš„hæ˜¯ä¸€æ ·çš„
        	ä¸Šå±‚æ¯æ¬¡è°ƒç”¨x264_encoder_encodeè¿›è¡Œç¼–ç éƒ½ä¼šå¾ªç¯åˆ‡x264_tï¼Œä¾‹å¦‚ç¼–ç ç¬¬ä¸€å¸§çš„æ—¶å€™ç”¨thread[1]å»æ‰§è¡Œslice_write(x264ç¬¬ä¸€å¸§æ˜¯ä»thread[1]å¼€å§‹çš„)ï¼Œç¼–ç ç¬¬äºŒå¸§çš„æ—¶å€™ç”¨thread[2]ï¼Œç¬¬ä¸‰å¸§ç”¨thread[3]ï¼Œç¬¬å››å¸§ç”¨thread[0]......
        */
        
        thread_prev    = h->thread[ h->i_thread_phase ];  // ä¸Šé¢ä¸Šä¸€å¸§æ‰€åœ¨çš„ä¸Šä¸‹æ–‡
        h->i_thread_phase = (h->i_thread_phase + 1) % h->i_thread_frames;
        thread_current = h->thread[ h->i_thread_phase ];  // ç¼–ç å½“å‰å¸§çš„ä¸Šä¸‹æ–‡
        /*
        	æœ€â€œæ—§â€å¸§çš„ä¸Šä¸‹æ–‡
        	å¦‚æœå½“å‰å¸§ç”¨çš„thread[0]åˆ™thread_oldestä¸ºthread[1]ï¼Œ
        	å¦‚æœå½“å‰å¸§ç”¨çš„thread[1]åˆ™thread_oldestä¸ºthread[2]ï¼Œ
        	å¦‚æœå½“å‰å¸§ç”¨çš„thread[3]åˆ™thread_oldestä¸ºthread[0]......
        	å› ä¸ºçº¿ç¨‹æ•°æ˜¯å›ºå®šçš„ï¼Œå¦‚æœå¼€å¯4ä¸ªçº¿ç¨‹æœ€å¤šåªèƒ½æœ‰4ä¸ªçº¿ç¨‹åœ¨æ‰§è¡Œç¼–ç ï¼Œæ‰€ä»¥å°†å½“å‰å¸§æŠ›ç»™å¯¹åº”çº¿ç¨‹æ‰§è¡Œç¼–ç æ—¶ä¹Ÿä¼šç­‰å¾…â€œæœ€æ—§â€çš„é‚£ä¸ªçº¿ç¨‹æ‰§è¡Œå®Œï¼Œå¦åˆ™ä¸‹ä¸€å¸§è¿›æ¥ç¼–ç æ—¶æ˜¯æ‰¾ä¸åˆ°ç©ºé—²çš„thread[x]ç»™å®ƒç”¨çš„(ç­‰å¾…æ“ä½œä¼šåœ¨encoder_frame_endä¸­è¿›è¡Œ)
        */
        thread_oldest  = h->thread[ (h->i_thread_phase + 1) % h->i_thread_frames ];
        /*
        	ä¸åŒçš„çº¿ç¨‹ä¹‹é—´éœ€è¦åšå¥½ä¿¡æ¯çš„åŒæ­¥ï¼Œæœ‰äº›ä¿¡æ¯åªå’Œè‡ªå·±æœ‰å…³ï¼Œä¾‹å¦‚h->fdecï¼Œh->fenc,å½“å‰å¸§çš„å®å—ä¿¡æ¯ç­‰
        	ä½†æœ‰äº›ä¿¡æ¯éœ€è¦åœ¨å¤šä¸ªçº¿ç¨‹ä¹‹é—´åŒæ­¥ï¼Œä¾‹å¦‚å‚è€ƒå¸§ï¼Œframe_numï¼Œç ç‡æƒ…å†µç­‰ç­‰
        */
        // ä¿¡æ¯åŒæ­¥
        thread_sync_context( thread_current, thread_prev );
        // ç æ§åŒæ­¥
        x264_thread_sync_ratecontrol( thread_current, thread_prev, thread_oldest );
        h = thread_current;
    }
    else
    {
        thread_current =
        thread_oldest  = h;
    }
    
    // ......
    
    /* Write frame */
    h->i_threadslice_start = 0;
    h->i_threadslice_end = h->mb.i_mb_height;
    if( h->i_thread_frames > 1 )
    {
        // å¸§çº§å¹¶è¡Œ
        x264_threadpool_run( h->threadpool, (void*)slices_write, h );
        h->b_thread_active = 1;
    }
    else if( h->param.b_sliced_threads )
    {
        // Sliceçº§å¹¶è¡Œ
        if( threaded_slices_write( h ) )
            return -1;
    }
    else
        if( (intptr_t)slices_write( h ) ) // å•çº¿ç¨‹
            return -1;
	// ç¼–ç æ”¶å°¾å·¥ä½œï¼Œ thread_oldestä¸ºæœ€æ—©çš„ä¸Šä¸‹æ–‡
    return encoder_frame_end( thread_oldest, thread_current, pp_nal, pi_nal, pic_out );
}

```



**è¿™é‡Œå…ˆçœ‹ä¸‹Sliceå¹¶è¡Œçš„å¤„ç†**

```c++
void x264_threadpool_run( x264_threadpool_t *pool, void *(*func)(void *), void *arg )
{
    // ä»uninité˜Ÿåˆ—ä¸­æ‹¿åˆ°ä¸€ä¸ªç©ºé—²jobï¼Œå°†å½“å‰ç¼–ç å‡½æ•°slice_writesæ”¾è¿›å»ï¼Œç„¶åpushè¿›runé˜Ÿåˆ—ä¸­
    x264_threadpool_job_t *job = (void*)x264_sync_frame_list_pop( &pool->uninit );
    job->func = func;
    job->arg  = arg;
    x264_sync_frame_list_push( &pool->run, (void*)job );
}


static int threaded_slices_write( x264_t *h )
{
    int round_bias = h->param.i_avcintra_class ? 0 : h->param.i_slice_count/2;

    /* set first/last mb and sync contexts */
    // ç¡®å®šå„ä¸ªSliceçš„èµ·å§‹å®å—ä½ç½®å’Œç»“æŸå®å—ä½ç½®
    for( int i = 0; i < h->param.i_threads; i++ )
    {
        x264_t *t = h->thread[i];
        if( i )
        {
            t->param = h->param;
            memcpy( &t->i_frame, &h->i_frame, offsetof(x264_t, rc) - offsetof(x264_t, i_frame) );
        }
        int height = h->mb.i_mb_height >> PARAM_INTERLACED;
        t->i_threadslice_start = ((height *  i    + round_bias) / h->param.i_threads) << PARAM_INTERLACED;
        t->i_threadslice_end   = ((height * (i+1) + round_bias) / h->param.i_threads) << PARAM_INTERLACED;
        t->sh.i_first_mb = t->i_threadslice_start * h->mb.i_mb_width;
        t->sh.i_last_mb  =   t->i_threadslice_end * h->mb.i_mb_width - 1;
    }

    x264_analyse_weight_frame( h, h->mb.i_mb_height*16 + 16 );

    x264_threads_distribute_ratecontrol( h );

    /* setup */
    for( int i = 0; i < h->param.i_threads; i++ )
    {
        h->thread[i]->i_thread_idx = i;
        h->thread[i]->b_thread_active = 1;
        x264_threadslice_cond_broadcast( h->thread[i], 0 );
    }
    /* dispatch */
    /*
    	æ‰§è¡Œslices_write
    	slice_writeå‡½æ•°æ˜¯å®Œæˆä¸€ä¸ªSliceçš„ç¼–ç ï¼Œæ­¤å‡½æ•°çš„å®ç°å¯ä»¥å‚è€ƒ"å®å—ç¼–ç æµç¨‹åˆ†æ.md"ç« èŠ‚
     */
    for( int i = 0; i < h->param.i_threads; i++ )
        x264_threadpool_run( h->threadpool, (void*)slices_write, h->thread[i] );
    /* wait */
    /*
    	ç­‰å¾…æ‰€æœ‰Sliceç¼–ç å®Œæˆ,æ‰€ä»¥Sliceå¹¶è¡Œæ˜¯ä¸ä¼šæœ‰å»¶è¿ŸN-1å¸§è¾“å‡ºçš„é—®é¢˜çš„
     */
    for( int i = 0; i < h->param.i_threads; i++ )
        x264_threadslice_cond_wait( h->thread[i], 1 );

    x264_threads_merge_ratecontrol( h );

    // è·å–è¾“å‡ºç æµï¼Œä»¥åŠå„ä¸ªSliceçš„ssimç­‰
    for( int i = 1; i < h->param.i_threads; i++ )
    {
        x264_t *t = h->thread[i];
        for( int j = 0; j < t->out.i_nal; j++ )
        {
            h->out.nal[h->out.i_nal] = t->out.nal[j];
            h->out.i_nal++;
            nal_check_buffer( h );
        }
        /* All entries in stat.frame are ints except for ssd/ssim. */
        for( int j = 0; j < (offsetof(x264_t,stat.frame.i_ssd) - offsetof(x264_t,stat.frame.i_mv_bits)) / sizeof(int); j++ )
            ((int*)&h->stat.frame)[j] += ((int*)&t->stat.frame)[j];
        for( int j = 0; j < 3; j++ )
            h->stat.frame.i_ssd[j] += t->stat.frame.i_ssd[j];
        h->stat.frame.f_ssim += t->stat.frame.f_ssim;
        h->stat.frame.i_ssim_cnt += t->stat.frame.i_ssim_cnt;
    }

    return 0;
}
```



**å¸§çº§å¹¶è¡Œçš„å¤„ç†**

å¸§çº§å¹¶è¡Œæ˜¯ç›´æ¥æ‰§è¡Œ  **x264_threadpool_run( h->threadpool, (void*)slices_write, h );**   ï¼Œ å°†ç¼–ç å‡½æ•°å°è£…æˆjob Pushè¿›runé˜Ÿåˆ—ä¸­ï¼Œç”±â€œ**å¤šçº¿ç¨‹åˆå§‹åŒ–æºç åˆ†æ**â€ä¸­åˆ›å»ºçš„çº¿ç¨‹ä¸æ–­å–runä¸­çš„jobæ‰§è¡Œï¼›

ä¸Šæ–‡æåˆ°å¸§çº§å¹¶è¡Œå¦‚æœPic_1ç¼–ç æ¯”è¾ƒå¿«æ—¶ä¼šæœ‰ä¸€ä¸ªé˜»å¡ç­‰å¾…Pic_0çš„è¿‡ç¨‹

é˜»å¡ã€å”¤é†’ç›¸å…³å‡½æ•°ä¸º**x264_frame_cond_wait**ï¼Œ**x264_frame_cond_broadcast**

```c++
/*
	å¸§frameæ¯ç¼–ç å®Œä¸€è¡Œå®å—éƒ½ç”¨è°ƒç”¨x264_frame_cond_broadcastï¼Œå”¤é†’å…¶ä»–é˜»å¡çš„çº¿ç¨‹
*/ 
void x264_frame_cond_broadcast( x264_frame_t *frame, int i_lines_completed )
{
    x264_pthread_mutex_lock( &frame->mutex );
    frame->i_lines_completed = i_lines_completed; // æ›´æ–°frameå·²ç»ç¼–ç çš„è¡Œæ•°
    x264_pthread_cond_broadcast( &frame->cv );
    x264_pthread_mutex_unlock( &frame->mutex );
}

/*
	å½¢å‚frameè¡¨ç¤ºå‚è€ƒçš„å¸§ï¼Œframe->i_lines_completedè¡¨ç¤ºå·²ç»ç¼–ç å®Œæˆçš„è¡Œæ•°
*/
void x264_frame_cond_wait( x264_frame_t *frame, int i_lines_completed )
{
    x264_pthread_mutex_lock( &frame->mutex );
    while( frame->i_lines_completed < i_lines_completed )  // å¦‚æœå‚è€ƒå¸§å·²ç¼–ç çš„è¡Œæ•°å°äºé¢„æœŸ(i_lines_completed)ï¼Œä¼šåœ¨è¿™é‡Œé˜»å¡ç­‰å¾…
        x264_pthread_cond_wait( &frame->cv, &frame->mutex );
    x264_pthread_mutex_unlock( &frame->mutex );
}
```



```c++
/*
	å¼€å¯å¸§çº§å¤šçº¿ç¨‹æ—¶ï¼Œåœ¨è¿›è¡Œå®å—åˆ†ææ—¶ä¼šè°ƒç”¨x264_frame_cond_wait
	ä¸‹é¢æˆªå–x264_frame_cond_waitè°ƒç”¨æ ˆ
*/

static intptr_t slice_write( x264_t *h )
{
	// ......
    x264_macroblock_analyse(h);
    // ......
}

void x264_macroblock_analyse( x264_t *h )
{
	// ......
    mb_analyse_init( h, &analysis, h->mb.i_qp );
    // ......
}

static void mb_analyse_init( x264_t *h, x264_mb_analysis_t *a, int qp )
{
    // ......
    if( h->sh.i_type != SLICE_TYPE_I )
    {
        // ......
        if( h->mb.i_mb_x == 0 && !(h->mb.i_mb_y & PARAM_INTERLACED) )
        {
            int mb_y = h->mb.i_mb_y >> SLICE_MBAFF;
            int thread_mvy_range = i_fmv_range;
            if( h->i_thread_frames > 1 )
            {
                int pix_y = (h->mb.i_mb_y | PARAM_INTERLACED) * 16; // ä¹˜ä¸Š16ï¼Œæ˜¯æŒ‰ç…§åƒç´ è¡Œæ•°è€Œä¸æ˜¯å®å—è¡Œæ•°
                /*
                	threshè¡¨ç¤ºå‚è€ƒå¸§å·²ç¼–ç è¡Œæ•°çš„ä¸‹é™é˜ˆå€¼ï¼Œå¦‚æœå‚è€ƒå¸§å·²ç¼–ç è¡Œæ•°å°äºè¿™ä¸ªé˜ˆå€¼ï¼Œå½“å‰å¸§ä¼šé˜»å¡ç­‰å¾…
                	thresh = pix_y + h->param.analyse.i_mv_range_thread;
                	pix_yè¡¨ç¤ºå½“å‰å¸§å·²ç»ç¼–ç çš„è¡Œæ•°(åƒç´ )ï¼Œh->param.analyse.i_mv_range_threadæ˜¯å¯é…ç½®å‚æ•°
                	h->param.analyse.i_mv_range_threadå°±å¯ä»¥è®¤ä¸ºä¸Šæ–‡æåˆ°çš„Nï¼Œå€¼è¶Šå°å¹¶è¡Œç¨‹åº¦è¶Šé«˜
                */
                int thresh = pix_y + h->param.analyse.i_mv_range_thread;
                for( int i = (h->sh.i_type == SLICE_TYPE_B); i >= 0; i-- )
                    for( int j = 0; j < h->i_ref[i]; j++ ) // éå†æ‰€æœ‰å‚è€ƒå¸§
                    {
                        x264_frame_cond_wait( h->fref[i][j]->orig, thresh );
                        thread_mvy_range = X264_MIN( thread_mvy_range, h->fref[i][j]->orig->i_lines_completed - pix_y );
                    }
            }
        }
        
    }
    // ......
}

```



```c++
/*
	å¼€å¯å¸§çº§å¤šçº¿ç¨‹æ—¶ï¼Œå¸§æ¯ç¼–ç å®Œä¸€è¡Œå®å—éƒ½ä¼šè°ƒç”¨x264_frame_cond_broadcast
	ä¸‹é¢æˆªå–x264_frame_cond_broadcastè°ƒç”¨æ ˆ
*/

static intptr_t slice_write( x264_t *h )
{
	// ......
    if( i_mb_x == 0 )
    {
        if( bitstream_check_buffer( h ) )
            return -1;
        if( !(i_mb_y & SLICE_MBAFF) && h->param.rc.i_vbv_buffer_size )
            bitstream_backup( h, &bs_bak[BS_BAK_ROW_VBV], i_skip, 1 );
        if( !h->mb.b_reencode_mb )
            fdec_filter_row( h, i_mb_y, 0 );
    }
    // ......
}

static void fdec_filter_row( x264_t *h, int mb_y, int pass )
{
    // ......
    int b_end = mb_y == h->i_threadslice_end;
    /* 
    	h->fdec->b_kept_as_refä¸º0,è¡¨ç¤ºå½“å‰å¸§ä¸ä¼šä½œä¸ºå‚è€ƒå¸§ï¼Œå³ä¸ä¼šæœ‰å…¶ä»–å¸§ä¾èµ–å½“å‰å¸§ï¼Œæ‰€ä»¥ä¸éœ€è¦è°ƒç”¨x264_frame_cond_broadcast
    	å¦‚æœå½“å‰å¸§å·²ç»ç¼–ç å®Œäº†ï¼Œå³b_endä¸ºtrueï¼Œåˆ™ä¼šåŠ ä¸Šä¸€ä¸ªæå¤§å€¼10000(10000å¯èƒ½æ˜¯ä¸ºäº†æ–¹ä¾¿ï¼Œä¹Ÿå¯ä»¥è®¾ç½®ä¸º8000ã€5wã€10wéƒ½è¡Œ)
    */
    if( h->i_thread_frames > 1 && h->fdec->b_kept_as_ref )
        x264_frame_cond_broadcast( h->fdec, mb_y*16 + (b_end ? 10000 : -(X264_THREAD_HEIGHT << SLICE_MBAFF)) );
    // ......
}
```



#### è¾“å‡º

**encoder_frame_end**

```c++
static int encoder_frame_end( x264_t *h, x264_t *thread_current,
                              x264_nal_t **pp_nal, int *pi_nal,
                              x264_picture_t *pic_out )
{
    char psz_message[80];

    if( !h->param.b_sliced_threads && h->b_thread_active )
    {
        // å¸§çº§å¹¶è¡Œæ‰ä¼šè¿›å…¥åˆ°è¿™é‡Œï¼Œè¿™ä¸ªhä¸ºæœ€æ—§çš„é‚£ä¸ªä¸Šä¸‹æ–‡ï¼Œè¿™é‡Œä¼šé˜»å¡ç­‰å¾…hè¿™ä¸€çº¿ç¨‹çš„å¸§ç¼–ç å®Œæˆï¼Œè¿™ä¹Ÿæ˜¯å¸§çº§å¹¶è¡Œä¼šå»¶è¿ŸN-1å¸§è¾“å‡ºçš„åœ°æ–¹
        h->b_thread_active = 0;
        if( (intptr_t)x264_threadpool_wait( h->threadpool, h ) )
            return -1;
    }
    // ......
}
```





### å‚è€ƒå¼•ç”¨

ğŸ±â€ğŸhttps://github.com/mirror/x264

