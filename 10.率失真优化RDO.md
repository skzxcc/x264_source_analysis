# Rate Distortion Optimization



## å•¥æ˜¯ç‡å¤±çœŸï¼Ÿ

Refï¼šhttps://zh.wikipedia.org/wiki/%E7%8E%87%E5%A4%B1%E7%9C%9F%E7%90%86%E8%AE%BA

**æ•°æ®ç‡å¤±çœŸç†è®º**ï¼ˆRate distortion theoryï¼‰æˆ–ç§°**ä¿¡æ¯ç‡-å¤±çœŸç†è®º**ï¼ˆinformation rate-distortion theoryï¼‰æ˜¯[ä¿¡æ¯è®º](https://zh.wikipedia.org/wiki/ä¿¡æ¯è®º)çš„ä¸»è¦åˆ†æ”¯ï¼Œå…¶çš„åŸºæœ¬é—®é¢˜å¯ä»¥å½’ç»“å¦‚ä¸‹ï¼šå¯¹äºä¸€ä¸ªç»™å®šçš„ä¿¡æºï¼ˆsource, input signalï¼‰åˆ†å¸ƒä¸[å¤±çœŸ](https://zh.wikipedia.org/wiki/å¤±çœŸ)åº¦é‡ï¼Œ**åœ¨ç‰¹å®šçš„[ç ç‡](https://zh.wikipedia.org/wiki/ç ç‡)ä¸‹èƒ½è¾¾åˆ°çš„æœ€å°æœŸæœ›å¤±çœŸï¼›æˆ–è€…ä¸ºäº†æ»¡è¶³ä¸€å®šçš„å¤±çœŸé™åˆ¶ï¼Œå¯å…è®¸çš„æœ€å¤§ç ç‡ä¸ºä½•**ï¼ŒD å®šä¹‰ä¸ºå¤±çœŸçš„ç¬¦å·



æˆ‘ä»¬çŸ¥é“åœ¨åŒæ ·çš„ç®—æ³•ä¸‹**ç ç‡(Rate)ä¸å¤±çœŸ(Distortion)ä¸¤è€…æ˜¯äº’æ–¥**çš„ã€‚ä¸€èˆ¬è€Œè¨€ç ç‡è¶Šé«˜å›¾åƒå¤±çœŸè¶Šå°ï¼Œç ç‡è¶Šä½å›¾åƒå¤±çœŸè¶Šå¤§ï¼›ç‡å¤±çœŸä¼˜åŒ–(RDO)çš„ä½œç”¨åœ¨**ç ç‡R**å’Œ**å¤±çœŸD**ä¸¤è€…çš„æƒè¡¡ä¸­å¾—åˆ°ä¸€ä¸ªæœ€ä¼˜è§£ï¼›

æ®çº¯æ•°å­¦çš„æ‹‰æ ¼æœ—æ—¥ä¹˜å­æ–¹æ³•ï¼Œå¯ä»¥æŠŠè¿™ç§æœ‰é™åˆ¶æ¡ä»¶çš„æœ€å€¼é—®é¢˜ï¼Œç­‰ä»·è½¬æ¢ä¸ºä¸å¸¦é™åˆ¶æ¡ä»¶çš„æ±‚æœ€å€¼é—®é¢˜ã€‚ç›¸åº”çš„ï¼Œæœ€ç»ˆ**RDOçš„ç›®çš„ä¹Ÿå°±å˜æˆï¼Œä½¿R-Dçš„costå‡½æ•°Jæœ€å°ã€‚**

```
J = D + lambda * R
```

Dè¡¨ç¤ºå¤±çœŸï¼ŒRè¡¨ç¤ºç ç‡ï¼Œlambdaä¸ºæ‹‰æ ¼æœ—æ—¥ä¹˜å­ï¼› é€šè¿‡è°ƒæ•´Dã€Rçš„å€¼ï¼Œä½¿ç”¨ä»£ä»·Jæœ€å°ã€‚ åœ¨x264ä¸­lambdaå€¼çš„å¤šå°‘ä¸å½“å‰å®å—çš„qpæœ‰å…³





## åŸç†åˆ†æ

 ç»“åˆ[å®å—åˆ†æä¹‹å¸§å†…ç¼–ç ](å®å—åˆ†æä¹‹å¸§å†…ç¼–ç .md)ï¼Œ[å®å—åˆ†æä¹‹å¸§é—´ç¼–ç ](å®å—åˆ†æä¹‹å¸§é—´ç¼–ç .md)ä¸¤ç¯‡æ–‡ç« å¯ä»¥çŸ¥é“ï¼Œåœ¨è¿›è¡Œå®å—ç±»å‹å†³ç­–çš„æ—¶å€™éœ€è¦è¿›è¡Œ**ç¼–ç ä»£ä»·é¢„ä¼°**ï¼Œé€‰æ‹©ç¼–ç ä»£ä»·æœ€å°çš„ä¸€ä¸ªå¯¹åº”çš„å®å—ç±»å‹ä½œä¸ºå½“å‰å®å—çš„ç±»å‹ã€‚è¿™é‡Œçš„**ç¼–ç ä»£ä»·**å°±æ˜¯ä¸Šé¢è¯´çš„**ç‡å¤±çœŸå€¼ï¼Œå³å…¬å¼ä¸­çš„J**



**æ­£å¸¸æ¥è¯´è¦è®¡ç®—å¾—åˆ°ç‡å¤±çœŸå€¼Jï¼Œéœ€è¦å…ˆçŸ¥é“å½“å‰å®å—çš„å¤±çœŸå€¼å’Œå½“å‰å®å—ç¼–ç åçš„æ¯”ç‰¹æ•°**ï¼Œå…¶ä¸­å¤±çœŸåº¦çš„è®¡ç®—ä¸ºå°†é‡æ„åçš„å®å—ä¸åŸå§‹å®å—åšSSD(æˆ–è€…å…¶ä»–æŒ‡æ ‡)çš„è®¡ç®—ï¼Œè¿™é‡Œå°±åˆ°éœ€è¦å…ˆå°†å®å—åšâ€œå˜æ¢-é‡åŒ–-åé‡åŒ–-åå˜æ¢-é‡æ„â€çš„æ“ä½œï¼› è€Œç¼–ç åçš„æ¯”ç‰¹æ•°æ˜¯åŒ…æ‹¬åƒç´ æ®‹å·®å’Œmb_layerå±‚çš„è¯­æ³•ç»è¿‡ç†µç¼–ç åæ‰€å æ¯”ç‰¹æ•°å¤§å°ã€‚

>  ä»¥Intraå®å—ä¸ºä¾‹ï¼Œæˆ‘ä»¬å¯ä»¥è®¾æƒ³ä¸€ä¸‹ï¼ŒIntraå®å—çš„åˆ†æéœ€è¦åˆ†æI16x16ã€I8x8ã€I4x4ä¸‰ç§å®å—ç±»å‹ï¼Œå…¶ä¸­I16x16æœ€å¤šæœ‰4ç§å¸§å†…é¢„æµ‹æ¨¡å¼ï¼ŒI8x8å’ŒI4x4æœ€å¤šæœ‰9ç§å¸§å†…é¢„æµ‹æ¨¡å¼ï¼› **é‚£ä¹ˆå•ä¸ªå®å—ç†è®ºä¸Šæœ€å¤šéœ€è¦è¿›è¡Œ ï¼ˆ1 * 4)  + (4 * 9) + (16 * 9) = 184æ¬¡çš„é¢„æµ‹åˆ†æ**ï¼Œå¦‚æœæ¯æ¬¡é¢„æµ‹åˆ†æ(è®¡ç®—ç‡å¤±çœŸå€¼)éƒ½ç»è¿‡â€œå˜æ¢-é‡åŒ–-åé‡åŒ–-åå˜æ¢-é‡æ„â€çš„æ“ä½œï¼Œ**å¯æƒ³è€ŒçŸ¥è¿™éƒ¨åˆ†çš„è®¡ç®—é‡æ˜¯å·¨å¤§çš„ï¼** 

**å› æ­¤å¤§éƒ¨åˆ†çš„å•†ç”¨ç¼–ç å™¨(x264è¿˜æ˜¯x265æˆ–è€…ã€openh264)åœ¨é€Ÿåº¦æ¯”è¾ƒå¿«çš„ç¼–ç æ¡£éƒ½ä¸ä¼šç”¨ä¸Šé¢è¯´çš„è¿™ç§æ–¹å¼è®¡ç®—å¤±çœŸå€¼ã€‚** 



å…¶ä¸­x264æä¾›ä¸‰ç§æ–¹å¼è®¡ç®—ç”¨äºè®¡ç®—ç‡å¤±çœŸå€¼ï¼Œ**SAD**ã€**SATD**å’Œ**SSD** ï¼ˆopenh264åªæä¾›sadã€satdä¸¤ç§ï¼‰ï¼Œ ä¸‰ç§æ–¹å¼çš„ç¼–ç é€Ÿåº¦ä¾æ¬¡é™ä½ï¼Œsadæœ€å¿«ï¼Œsatdæ¬¡ä¹‹ï¼Œssdæœ€æ…¢ ï¼Œå…¶ä¸­sadå’Œsatdéƒ½å±äºå¿«é€Ÿç®—æ³•

*ï¼ˆå…³äºsad/satdçš„è®¡ç®—å¯ä»¥ç™¾åº¦ï¼Œåœ¨å®å—åˆ†æçš„ç« èŠ‚ä¹Ÿæœ‰åšä»‹ç»ï¼‰*

#### â‘  SADè®¡ç®—ç‡å¤±çœŸ

è¿˜æ˜¯å›å½’åˆ°ä¸Šè¿°é‚£æ¡å…¬å¼ **J = D + lambda * R**

x264ä¸ºäº†æé«˜é¢„æµ‹è¿‡ç¨‹ä¸­å®å—åˆ†æçš„é€Ÿåº¦ï¼Œå¼•å…¥äº†sadå’Œsatdçš„è¡¡é‡ç®—æ³•ã€‚

æ­¤æ—¶ä¸Šè¿°çš„å¤±çœŸå€¼Dç”¨**é¢„æµ‹å®å—ä¸åŸå§‹å®å—çš„åƒç´ sadè¡¨ç¤º**ï¼Œæ­¤æ—¶å°±ä¸éœ€è¦è¿›è¡Œâ€œå˜æ¢-é‡åŒ–-åé‡åŒ–-åå˜æ¢-é‡æ„â€çš„æ“ä½œäº†ï¼Œä¹Ÿå¤§å¤§èŠ‚çœäº†ç¼–ç æ—¶é—´ï¼› 

ç”±äºæ²¡æœ‰è¿›è¡Œâ€œç¼–ç â€çš„æ“ä½œæ˜¯ä¸èƒ½çŸ¥é“å½“å‰å®å—çœŸæ­£ç¼–ç åçš„æ¯”ç‰¹æ•°çš„ï¼Œå¯¹äºIntraå®å—Rç”¨äºè¡¨ç¤º**å½“å‰å®å—é¢„æµ‹æ¨¡å¼**çš„Bitså¼€é”€ï¼Œè€Œå¯¹äºå¸§é—´å®å—Rç”¨äºè¡¨ç¤º**å½“å‰å®å—è¿åŠ¨çŸ¢é‡**çš„Bitså¼€é”€

lambdaçš„å–å€¼ä¸å½“å‰å®å—çš„QPæœ‰å…³ï¼Œæ¯ä¸ªQPå¯¹åº”ä¸€ä¸ªlambdaï¼Œä¸‹é¢æ˜¯x264çš„lambdaè¡¨

```c++
/* lambda = pow(2,qp/6-2) */
const uint16_t x264_lambda_tab[QP_MAX_MAX+1] =
{
   1,   1,   1,   1,   1,   1,   1,   1, /*  0- 7 */
   1,   1,   1,   1,   1,   1,   1,   1, /*  8-15 */
   2,   2,   2,   2,   3,   3,   3,   4, /* 16-23 */
   4,   4,   5,   6,   6,   7,   8,   9, /* 24-31 */
  10,  11,  13,  14,  16,  18,  20,  23, /* 32-39 */
  25,  29,  32,  36,  40,  45,  51,  57, /* 40-47 */
  64,  72,  81,  91, 102, 114, 128, 144, /* 48-55 */
 161, 181, 203, 228, 256, 287, 323, 362, /* 56-63 */
 406, 456, 512, 575, 645, 724, 813, 912, /* 64-71 */
1024,1149,1290,1448,1625,1825,2048,2299, /* 72-79 */
2580,2896,                               /* 80-81 */
};
```



#### â‘¡ SATDè®¡ç®—ç‡å¤±çœŸ

satdæ–¹å¼å’Œsadçš„åŸºæœ¬å·®ä¸å¤šï¼ŒRå’Œlambdaçš„å–å€¼ä¸SADä¸€æ ·ã€‚åªæ˜¯Dçš„è®¡ç®—æœ‰ç‚¹å·®å¼‚ï¼Œè¿™é‡Œç”¨çš„æ˜¯**é¢„æµ‹å®å—ä¸åŸå§‹å®å—çš„åƒç´ satdè¡¨ç¤º**

ç”±äºsatdå°±æ˜¯sadåœ¨ç»è¿‡hadamardå˜æ¢åçš„å€¼ï¼Œæ‰€ä»¥é€Ÿåº¦ä¼šæ…¢ä¸€ç‚¹ç‚¹



#### â‘¢ SSDè®¡ç®—ç‡å¤±çœŸ

SSDçš„æ–¹å¼å°±æ˜¯ä¸Šé¢è¯´çš„ **å°†å®å—åšâ€œå˜æ¢-é‡åŒ–-åé‡åŒ–-åå˜æ¢-é‡æ„â€çš„æ“ä½œ**, **æ—¶é—´å¤æ‚åº¦æ˜¯æœ€é«˜çš„ï¼ŒåŒæ—¶è®¡ç®—å‡ºæ¥çš„ç‡å¤±çœŸå€¼ä¹Ÿæ˜¯æœ€å‡†ç¡®çš„**ã€‚  **è¿™ä¹Ÿæ˜¯æœ¬ç« èŠ‚è¦æåˆ°å¾—ç‡å¤±çœŸä¼˜åŒ–ï¼ˆRDOï¼‰**

Dï¼šç”¨é‡æ„åçš„å®å—ä¸åŸå§‹å®å—çš„SSDè¡¨ç¤º

Rï¼šå½“å‰å®å—çš„mb_layerå¥æ³•ä»¥åŠæ®‹å·®ç»è¿‡ç†µç¼–ç åçš„æ¯”ç‰¹æ•°

lambdaï¼š**è¿™é‡Œçš„lambdaä¸sadã€satdçš„è¡¨ä¸å¤ªä¸€æ ·ï¼Œx264ä¸­å°†åšlambda2**

```c++
/* lambda2 = pow(lambda,2) * .9 * 256 */
/* Capped to avoid overflow */
const int x264_lambda2_tab[QP_MAX_MAX+1] =
{
       14,       18,       22,       28,       36,       45,      57,      72, /*  0- 7 */
       91,      115,      145,      182,      230,      290,     365,     460, /*  8-15 */
      580,      731,      921,     1161,     1462,     1843,    2322,    2925, /* 16-23 */
     3686,     4644,     5851,     7372,     9289,    11703,   14745,   18578, /* 24-31 */
    23407,    29491,    37156,    46814,    58982,    74313,   93628,  117964, /* 32-39 */
   148626,   187257,   235929,   297252,   374514,   471859,  594505,  749029, /* 40-47 */
   943718,  1189010,  1498059,  1887436,  2378021,  2996119, 3774873, 4756042, /* 48-55 */
  5992238,  7549747,  9512085, 11984476, 15099494, 19024170,23968953,30198988, /* 56-63 */
 38048341, 47937906, 60397977, 76096683, 95875813,120795955,                   /* 64-69 */
134217727,134217727,134217727,134217727,134217727,134217727,                   /* 70-75 */
134217727,134217727,134217727,134217727,134217727,134217727,                   /* 76-81 */
};
```



### é±¼å’Œç†ŠæŒä¸å¯å…¼å¾—

**sadã€satdçš„è®¡ç®—ä¼šæ¯”ssdé€Ÿåº¦å¿«å¾ˆå¤šï¼Œä½†å¾—åˆ°å¾—ç‡å¤±çœŸå€¼å¹¶ä¸ä¸€å®šæ˜¯æœ€å‡†ç¡®çš„ã€‚**

sadå’Œsatdè®¡ç®—å¾—åˆ°çš„ç‡å¤±çœŸå€¼ä¸ºä»€ä¹ˆä¸æ˜¯æœ€å‡†ç¡®çš„å‘¢ï¼ŒåŸå› å¦‚ä¸‹ï¼š

- SADè¡¨ç¤ºç»å¯¹è¯¯å·®å’Œï¼Œåæ˜ çš„åªæ˜¯æ®‹å·®çš„å¤§å°ï¼Œä¸èƒ½åæ˜ é¢‘åŸŸä¸Šçš„ä¿¡æ¯ï¼Œç”±äºåœ¨ç¼–ç å™¨å†…éƒ¨çœŸæ­£è¿›è¡Œé‡åŒ–çš„é’ˆå¯¹DCTå˜æ¢ä¹‹åçš„æ•°æ®ï¼Œæ‰€ä»¥SADæœ€å°çš„æ®‹å·®ç»è¿‡å˜æ¢ä¹‹åçš„æ®‹å·®å¹¶ä¸ä¸€å®šæ˜¯æœ€å°çš„

- SATDæ˜¯å°†SADç»è¿‡hadamardå˜æ¢åçš„æ•°æ®ï¼Œèƒ½åæ˜ é¢‘åŸŸä¸Šçš„ä¿¡æ¯ï¼Œä½†hadamardå˜æ¢ä¸DCTä¸å®Œå…¨ç›¸åŒï¼Œæ‰€ä»¥SATDæœ€å°çš„æ•°æ®ï¼Œç»è¿‡DCTå˜æ¢åçš„æ®‹å·®ä¹Ÿä¸ä¸€å®šæ˜¯æœ€å°çš„

- ä¸ç®¡æ˜¯SADè¿˜æ˜¯SATDï¼Œéƒ½ä¸ä¼šç»è¿‡å˜æ¢ã€é‡åŒ–ã€ç†µç¼–ç ã€‚æ‰€ä»¥Rå€¼ä¹Ÿä¸æ˜¯å‡†ç¡®å€¼

ä¸¾ä¸ªç®€å•çš„ä¾‹å­ï¼šä¸¤ç»„ç»è¿‡å˜åŒ–åçš„æ®‹å·®ä¹‹[13,1]ï¼Œ[5,5]ã€‚ ç¬¬ä¸€ä¸ªçš„satdä¸º14ï¼Œç¬¬äºŒä¸ªçš„satdæ˜¯10ï¼Œä½†å¦‚æœä¸¤è€…ä»¥Step=6è¿›è¡Œé‡åŒ–å˜æˆ[13/6, 1/6] = [2,0]ï¼› [5/6, 5/6] = [0,0]ï¼› å†ç»è¿‡åé‡åŒ–æ¢å¤æˆ[2x6 , 0x6] = [12,0]; [0x6, 0x6] = [0,0]; å¾ˆæ˜æ˜¾ç¬¬ä¸€ä¸ªçš„æŸå¤±æ›´å°ï¼Œä½†å®ƒçš„satdä¼šæ›´å¤§



æ­£æ˜¯ç”±äºsadã€satdé€Ÿåº¦å¿«çš„ä¼˜ç‚¹ï¼Œ*(ä»¥å¸§å†…ç¼–ç ä¸ºä¾‹)* x264åœ¨åšIntra16x16å››ç§å¸§å†…æ¨¡å¼ï¼Œ Intra8x8ã€Intra4x4ä¹ç§å¸§å†…æ¨¡å¼åˆ†ææ—¶ï¼Œä¼šé€‰ç”¨sad/satdè®¡ç®—å¾—åˆ°å„è‡ªçš„ç¼–ç ä»£ç i_satd_i16x16ã€i_satd_i8x8ã€i_satd_i4x4ã€‚æ­¤æ—¶å¦‚æœæ²¡å¼€å¯ç‡å¤±çœŸä¼˜åŒ–çš„è¯å°±é€‰æ‹©æœ€å°çš„å°±è¡Œã€‚

å¦‚æœå¼€å¯ç‡å¤±çœŸä¼˜åŒ–çš„è¯ä¼šè¿›ä¸€æ­¥è®¡ç®—ç‡å¤±çœŸå€¼ï¼Œå…¶ä¸­å¸§å†…ç¼–ç æä¾›ä¸‰ç§RDOæ–¹å¼ï¼Œã€RD mode decisionã€‘ã€ã€RD refinementã€‘ã€ã€QPRDã€‘ï¼Œä¸‰ç§æ–¹å¼ç‡å¤±çœŸç¨‹åº¦ä¾æ¬¡è¶Šæ¥è¶Šé«˜ï¼Œé€Ÿåº¦ä¹Ÿè¶Šæ¥è¶Šæ…¢

- **RD mode decision**ï¼Œ  é‡æ–°ç¡®å®šå¸§å†…å®å—åˆ’åˆ†å½¢å¼

æ ¹æ®å‰é¢intra16x16ã€intra8x8ã€intra4x4åˆ†æå¾—åˆ°çš„ä¸åŒå®å—åˆ’åˆ†ä¸‹æœ€ä¼˜é¢„æµ‹æ¨¡å¼ï¼Œç„¶åé‡æ–°è®¡ç®—intra16x16ã€intra8x8ã€intra4x4åœ¨å„è‡ªæœ€ä¼˜å¸§å†…é¢„æµ‹æ¨¡å¼ä¸‹SSDæ–¹å¼çš„ç‡å¤±çœŸå€¼ï¼Œ ç»“æœåˆ†åˆ«å¹…å€¼ç»™satd_i16x16ã€i_satd_i8x8ã€i_satd_i4x4ã€‚ **é€‰æ‹©æœ€å°çš„ä½œä¸ºå½“å‰å®å—çš„åˆ’åˆ†ç±»å‹**ã€‚

- **RD refinement**ï¼Œ é‡æ–°ç¡®å®šå¸§å†…æ¨¡å¼

ç»è¿‡**RD mode decision**ä¹‹åï¼Œå®å—çš„åˆ’åˆ†ç±»å‹å·²ç»ç¡®å®šäº†(intra16x16ã€intra8x8ã€intra4x4å…¶ä¸­ä¸€ç§)ï¼Œ RD refinementçš„ä½œç”¨æ˜¯é‡æ–°è®¡ç®—å½“å‰ç±»å‹ä¸‹å¯ç”¨å¸§å†…é¢„æµ‹æ¨¡å¼ä¸‹SSDæ–¹å¼çš„ç‡å¤±çœŸå€¼ã€‚ å¦‚æœå½“å‰å®å—ç±»å‹æ˜¯intra16x16é‚£ä¹ˆä¼šå¯¹å…¶4ç§å¸§å†…æ¨¡å¼(H,V,DC,Plane)çš„ç‡å¤±çœŸå€¼é‡æ–°è®¡ç®—ã€‚ **é€‰æ‹©æœ€å°çš„æ¨¡å¼ä½œä¸ºå½“å‰å®å—çš„å¸§å†…é¢„æµ‹æ¨¡å¼**

- **QPRD**

ç»è¿‡**RD mode decision**ã€**RD refinement**ç¡®å®šå®å—åˆ’åˆ†ç±»å‹ä»¥åŠå¸§å†…æ¨¡å¼çš„åŸºç¡€ä¸Šï¼Œå°è¯•è°ƒæ•´å½“å‰å®å—çš„QPå€¼ï¼Œé‡æ–°è®¡ç®—ç‡å¤±çœŸå€¼ï¼Œ**é€‰æ‹©RDæœ€å°çš„QPä½œä¸ºå½“å‰å®å—çš„ç¼–ç QP**





## ç‡å¤±çœŸä¼˜åŒ–æºç åˆ†æ

*æœ¬æ–‡ä¸»è¦ä»‹ç»SLICE_TYPE_Iä¸­çš„RDOåˆ†æï¼Œå¯¹äºéSLICE_TYPE_Içš„åœ°æ–¹çš„RDOä¹Ÿæ˜¯ç±»ä¼¼ï¼Œå›ºä¸é‡å¤ä»‹ç»*



åœ¨å®å—åˆ†æå‡½æ•°x264_macroblock_analyseä¸­æœ‰ä½¿ç”¨åˆ°RDOï¼Œåœ¨æ­¤ä¹‹å‰æˆ‘ä»¬å…ˆçœ‹çœ‹RDOåœ¨ä»€ä¹ˆæ—¶å€™æ‰å¼€å¯

```c++
// æˆªå–éƒ¨åˆ†ä»£ç 
/* i_mbrdçš„å€¼è¶Šå¤§,è¿›è¡Œç‡å¤±çœŸä¼˜åŒ–çš„ç¨‹åº¦å°±è¶Šé«˜ï¼Œç›¸åº”çš„é€Ÿåº¦å°±ä¼šè¶Šæ…¢ */
static void mb_analyse_init( x264_t *h, x264_mb_analysis_t *a, int qp ){
    int subme = h->param.analyse.i_subpel_refine - (h->sh.i_type == SLICE_TYPE_B);
	
    /* mbrd == 1 -> RD mode decision */
    /* mbrd == 2 -> RD refinement */
    /* mbrd == 3 -> QPRD */
    a->i_mbrd = (subme>=6) + (subme>=8) + (h->param.analyse.i_subpel_refine>=10); // æ˜¯å¦å¯¹å½“å‰å®å—è¿›è¡ŒRDO
}
```

å¯ä»¥çœ‹å‡ºï¼Œsubmeè‡³å°‘å¤§äºç­‰äº6(å³h->param.analyse.i_subpel_refineè‡³å°‘éœ€è¦>=6)æ‰ä¼šå¼€å¯RDO



#### æ‹‰æ ¼æœ—æ—¥ä¹˜å­

J = D + lambda * Rå…¬å¼ä¸­ï¼Œlambdaè¡¨ç¤ºæ‹‰æ ¼æœ—æ—¥ä¹˜å­ï¼Œåœ¨ä¸‹é¢çš„x264æºç åˆ†æä¸­ä¼šå¤šæ¬¡å‡ºç°**lambda2(æ‹‰æ ¼æœ—æ—¥ä¹˜å­)**ï¼Œ**å®ƒçš„å€¼ä¸æ˜¯å›ºå®šä¸å˜çš„ï¼Œè€Œæ˜¯ç”±å½“å‰å®å—çš„QPå†³å®š**

æ³¨æ„é™¤äº†x264_lambda2_tabè¿˜æœ‰**x264_lambda_tab**ï¼Œä¸¤è€…æ˜¯ä¸ä¸€æ ·çš„ã€‚**å‰è€…æ˜¯ç”¨äºssdçš„ç‡å¤±çœŸè®¡ç®—(ä¹Ÿå°±æ˜¯æœ¬æ–‡è¦è®²çš„å†…å®¹)**ï¼Œåè€…æ˜¯ç”¨äºsad/satdçš„ç‡å¤±çœŸè®¡ç®—çš„

```c++
/* lambda = pow(2,qp/6-2) */ // è¿™ä¸ªåœ¨sad/satdè®¡ç®—ç¼–ç ä»£ç çš„æ—¶å€™ä¼šç”¨åˆ°
const uint16_t x264_lambda_tab[QP_MAX_MAX+1] =
{
   1,   1,   1,   1,   1,   1,   1,   1, /*  0- 7 */
   1,   1,   1,   1,   1,   1,   1,   1, /*  8-15 */
   2,   2,   2,   2,   3,   3,   3,   4, /* 16-23 */
   4,   4,   5,   6,   6,   7,   8,   9, /* 24-31 */
  10,  11,  13,  14,  16,  18,  20,  23, /* 32-39 */
  25,  29,  32,  36,  40,  45,  51,  57, /* 40-47 */
  64,  72,  81,  91, 102, 114, 128, 144, /* 48-55 */
 161, 181, 203, 228, 256, 287, 323, 362, /* 56-63 */
 406, 456, 512, 575, 645, 724, 813, 912, /* 64-71 */
1024,1149,1290,1448,1625,1825,2048,2299, /* 72-79 */
2580,2896,                               /* 80-81 */
};

// ä¸åŒQPå¯¹åº”çš„æ‹‰æ ¼æœ—æ—¥ä¹˜å­
const int x264_lambda2_tab[QP_MAX_MAX+1] =
{
       14,       18,       22,       28,       36,       45,      57,      72, /*  0- 7 */
       91,      115,      145,      182,      230,      290,     365,     460, /*  8-15 */
      580,      731,      921,     1161,     1462,     1843,    2322,    2925, /* 16-23 */
     3686,     4644,     5851,     7372,     9289,    11703,   14745,   18578, /* 24-31 */
    23407,    29491,    37156,    46814,    58982,    74313,   93628,  117964, /* 32-39 */
   148626,   187257,   235929,   297252,   374514,   471859,  594505,  749029, /* 40-47 */
   943718,  1189010,  1498059,  1887436,  2378021,  2996119, 3774873, 4756042, /* 48-55 */
  5992238,  7549747,  9512085, 11984476, 15099494, 19024170,23968953,30198988, /* 56-63 */
 38048341, 47937906, 60397977, 76096683, 95875813,120795955,                   /* 64-69 */
134217727,134217727,134217727,134217727,134217727,134217727,                   /* 70-75 */
134217727,134217727,134217727,134217727,134217727,134217727,                   /* 76-81 */
};

static void mb_analyse_init_qp( x264_t *h, x264_mb_analysis_t *a, int qp )
{
    int effective_chroma_qp = h->chroma_qp_table[SPEC_QP(qp)] + X264_MAX( qp - QP_MAX_SPEC, 0 );
    a->i_lambda = x264_lambda_tab[qp];
    a->i_lambda2 = x264_lambda2_tab[qp];  // qpè¡¨ç¤ºå½“å‰å®å—çš„QP
	// ......
}
```



#### **å®å—åˆ†æä¸­Intraå®å—åˆ†ææ—¶çš„RDO**

```c++
// æˆªå–éƒ¨åˆ†ä»£ç 
void x264_macroblock_analyse( x264_t *h ) {
    // ......
    if( h->sh.i_type == SLICE_TYPE_I )  // I_Sliceåªèƒ½åŒ…å«Intraå®å—
    {
intra_analysis:
        if( analysis.i_mbrd )
            mb_init_fenc_cache( h, analysis.i_mbrd >= 2 );
        mb_analyse_intra( h, &analysis, COST_MAX ); // å¸¸è§„çš„Intraå®å—åˆ†æ
        if( analysis.i_mbrd )
            intra_rd( h, &analysis, COST_MAX ); // RDOä¼˜åŒ–: RD mode decision

        i_cost = analysis.i_satd_i16x16;
        h->mb.i_type = I_16x16;
        COPY2_IF_LT( i_cost, analysis.i_satd_i4x4, h->mb.i_type, I_4x4 );
        COPY2_IF_LT( i_cost, analysis.i_satd_i8x8, h->mb.i_type, I_8x8 );
        if( analysis.i_satd_pcm < i_cost )
            h->mb.i_type = I_PCM;

        else if( analysis.i_mbrd >= 2 )
            intra_rd_refine( h, &analysis ); // RDOä¼˜åŒ–: RD refinement
    }
    // ......
    if( analysis.i_mbrd == 3 && !IS_SKIP(h->mb.i_type) )
        mb_analyse_qp_rd( h, &analysis );  // RDOä¼˜åŒ–: QPRD
    // ......
}
```





#### å½“mbrdç­‰äº1æ—¶çš„RDOï¼š RD mode decisionï¼Œæ¨¡å¼å†³ç­–

ç»“åˆä¸Šè¿°ä»£ç ï¼Œå¦‚æœæ²¡å¼€å¯RDOå³i_mbrd=0çš„æƒ…å†µä¸‹ï¼Œä»£ä»·å€¼i_costä¼šé€‰æ‹©mb_analyse_intraä¸­è®¡ç®—å¾—åˆ°çš„analysis.i_satd_i16x16ã€analysis.i_satd_i8x8ã€analysis.i_satd_i4x4ä¸­æœ€å°çš„ä¸€ä¸ª(mb_analyse_intraçš„åˆ†æå‚è€ƒ[å®å—åˆ†æä¹‹å¸§å†…ç¼–ç ](å®å—åˆ†æä¹‹å¸§å†…ç¼–ç .md)ï¼Œé‡Œé¢å°±æ˜¯è®¡ç®—SAD/SATD)ã€‚  å¦‚æœå¼€å¯RDOåˆ™ä¼šè¿›å…¥åˆ°**intra_rd**åšè¿›ä¸€æ­¥çš„åˆ†æï¼Œé€‰æ‹©ç‡å¤±çœŸæœ€å°çš„ä½œä¸ºä»£ä»·æœ€å°å€¼ã€‚

**mode decisionï¼šå¯¹Intra16x16ã€Intra8x8ã€Intra4x4ä¸‰ç§å®å—ç±»å‹é‡æ–°é€šè¿‡RDå€¼åˆ¤æ–­å­°ä¼˜å­°åŠ£ï¼Œæ‹©ä¼˜é€‰æ‹©**



**intra_rd**

```c++
/*
	ç”±äºmb_analyse_intraä¸­è®¡ç®—çš„i_satd_i16x16/i_satd_i8x8/i_satd_i4x4éƒ½æ˜¯SAD/STADå€¼ï¼Œå…¶ç‡å¤±çœŸä¸ä¸€å®šæ˜¯æœ€å°çš„ï¼Œ
	æ‰€ä»¥é€šè¿‡intra_rdå¯¹i_satd_i16x16/i_satd_i8x8/i_satd_i4x4é‡æ–°è®¡ç®—
*/
static void intra_rd( x264_t *h, x264_mb_analysis_t *a, int i_satd_thresh )
{
    if( !a->b_early_terminate )
        i_satd_thresh = COST_MAX;

    if( a->i_satd_i16x16 < i_satd_thresh )
    {
        // è¿›è¡ŒI16x16ç±»å‹çš„ç‡å¤±çœŸåˆ†æ
        h->mb.i_type = I_16x16;
        analyse_update_cache( h, a ); // ä¸»è¦æ˜¯è®¡ç®—è‰²åº¦å—çš„ç¼–ç ä»£ä»·
        a->i_satd_i16x16 = rd_cost_mb( h, a->i_lambda2 );  // é‡æ–°è®¡ç®—ç‡å¤±çœŸå€¼(RD)
    }
    else
        a->i_satd_i16x16 = COST_MAX;

    if( a->i_satd_i4x4 < i_satd_thresh )
    {
        // è¿›è¡ŒI4x4ç±»å‹çš„ç‡å¤±çœŸåˆ†æ
        h->mb.i_type = I_4x4; 
        analyse_update_cache( h, a ); // ä¸»è¦æ˜¯è®¡ç®—è‰²åº¦å—çš„ç¼–ç ä»£ä»·
        a->i_satd_i4x4 = rd_cost_mb( h, a->i_lambda2 ); // é‡æ–°è®¡ç®—ç‡å¤±çœŸå€¼(RD)
    }
    else
        a->i_satd_i4x4 = COST_MAX;

    if( a->i_satd_i8x8 < i_satd_thresh )
    {
        // è¿›è¡ŒI8x8ç±»å‹çš„ç‡å¤±çœŸåˆ†æ
        h->mb.i_type = I_8x8;
        analyse_update_cache( h, a ); // ä¸»è¦æ˜¯è®¡ç®—è‰²åº¦å—çš„ç¼–ç ä»£ä»·
        a->i_satd_i8x8 = rd_cost_mb( h, a->i_lambda2 ); // é‡æ–°è®¡ç®—ç‡å¤±çœŸå€¼(RD)
        a->i_cbp_i8x8_luma = h->mb.i_cbp_luma;
    }
    else
        a->i_satd_i8x8 = COST_MAX;
}
```



**analyse_update_cache**

```c++
static void analyse_update_cache( x264_t *h, x264_mb_analysis_t *a  )
{
    /*
    	å¯¹äºIntraå®å—ä¸»è¦æ˜¯è¿›è¡Œè‰²åº¦å—çš„ä»£ä»·è®¡ç®—
    */
    switch( h->mb.i_type )
    {
        case I_4x4:
            for( int i = 0; i < 16; i++ )
                h->mb.cache.intra4x4_pred_mode[x264_scan8[i]] = a->i_predict4x4[i];
            
            mb_analyse_intra_chroma( h, a );  // è‰²åº¦å—ä»£ä»·åˆ†æï¼Œä¸mb_analyse_intraè¿‡ç¨‹ç±»ä¼¼ï¼Œè¿™é‡Œä¸è¿‡è¿›ä¸€æ­¥åˆ†æ
            break;
        case I_8x8:
            for( int i = 0; i < 4; i++ )
                x264_macroblock_cache_intra8x8_pred( h, 2*(i&1), 2*(i>>1), a->i_predict8x8[i] );

            mb_analyse_intra_chroma( h, a );
            break;
        case I_16x16:
            h->mb.i_intra16x16_pred_mode = a->i_predict16x16;
            mb_analyse_intra_chroma( h, a );
            break;

        case I_PCM:
            break;
		// ......
    }
#endif
}
```



**rd_cost_mb**

```c++
static int rd_cost_mb( x264_t *h, int i_lambda2 )
{
    int b_transform_bak = h->mb.b_transform_8x8;
    int i_ssd;
    int i_bits;
    int type_bak = h->mb.i_type;

    x264_macroblock_encode( h ); // å¯¹å½“å‰å®å—è¿›è¡Œç¼–ç 

    if( h->mb.b_deblock_rdo )
        x264_macroblock_deblock( h ); // å¦‚æœå¼€å¯b_deblock_rdoä¼šè¿›è¡Œæ»¤æ³¢

    i_ssd = ssd_mb( h ); // è®¡ç®—ç¼–ç -é‡å»ºåçš„å®å—ä¸åŸå§‹å®å—çš„ssdå€¼ï¼Œå³ä¸Šè¿°ç‡å¤±çœŸä¼˜åŒ–å…¬å¼çš„â€˜Dâ€™

    /* i_bitså¯ä»¥è®¤ä¸ºæ˜¯lambda * R, Rè¡¨ç¤ºç ç‡ */
    if( IS_SKIP( h->mb.i_type ) )
    {
        i_bits = (1 * i_lambda2 + 128) >> 8;
    }
    else if( h->param.b_cabac )
    {
        x264_cabac_t cabac_tmp;
        COPY_CABAC;
        macroblock_size_cabac( h, &cabac_tmp );
        i_bits = ( (uint64_t)cabac_tmp.f8_bits_encoded * i_lambda2 + 32768 ) >> 16;
    }
    else
    {
        macroblock_size_cavlc( h );
        i_bits = ( (uint64_t)h->out.bs.i_bits_encoded * i_lambda2 + 128 ) >> 8;
    }

    h->mb.b_transform_8x8 = b_transform_bak;
    h->mb.i_type = type_bak;
	// J = D + Î» * Rï¼Œå³ä¸Šè¿°ç‡å¤±çœŸä¼˜åŒ–å…¬å¼ 
    return X264_MIN( i_ssd + i_bits, COST_MAX );
}
```



> SSDï¼ŒSum of Squared Differencesï¼Œ è¯¯å·®å¹³æ–¹å’Œ

```c++
static inline int ssd_mb( x264_t *h )
{
    // è®¡ç®—äº®åº¦å—çš„SSD
    int i_ssd = ssd_plane( h, PIXEL_16x16, 0, 0, 0 );
    if( CHROMA_FORMAT )
    {
        // è‰²åº¦å—çš„SSD
        int chroma_size = h->luma2chroma_pixel[PIXEL_16x16];
        int chroma_ssd = ssd_plane( h, chroma_size, 1, 0, 0 ) + ssd_plane( h, chroma_size, 2, 0, 0 );
        i_ssd += ((uint64_t)chroma_ssd * h->mb.i_chroma_lambda2_offset + 128) >> 8;
    }
    return i_ssd;
}
```



```C++
static inline int ssd_plane( x264_t *h, int size, int p, int x, int y )
{
    int satd = 0;
    pixel *fdec = h->mb.pic.p_fdec[p] + x + y*FDEC_STRIDE;
    pixel *fenc = h->mb.pic.p_fenc[p] + x + y*FENC_STRIDE;
    if( p == 0 && h->mb.i_psy_rd )  // å¦‚æœå¼€å¯PSYæ‰è¿›å…¥åˆ°æ­¤å¤„
    {
        /* If the plane is smaller than 8x8, we can't do an SA8D; this probably isn't a big problem. */
        if( size <= PIXEL_8x8 )
        {
            uint64_t fdec_acs = h->pixf.hadamard_ac[size]( fdec, FDEC_STRIDE );
            uint64_t fenc_acs = cached_hadamard( h, size, x, y );
            satd = abs((int32_t)fdec_acs - (int32_t)fenc_acs)
                 + abs((int32_t)(fdec_acs>>32) - (int32_t)(fenc_acs>>32));
            satd >>= 1;
        }
        else
        {
            int dc = h->pixf.sad[size]( fdec, FDEC_STRIDE, (pixel*)x264_zero, 0 ) >> 1;
            satd = abs(h->pixf.satd[size]( fdec, FDEC_STRIDE, (pixel*)x264_zero, 0 ) - dc - cached_satd( h, size, x, y ));
        }
        satd = (satd * h->mb.i_psy_rd * h->mb.i_psy_rd_lambda + 128) >> 8;
    }
    // è®¡ç®—ssd
    return h->pixf.ssd[size](fenc, FENC_STRIDE, fdec, FDEC_STRIDE) + satd;
}
```



h->pixf.ssdæ˜¯ä¸€ä¸ªå‡½æ•°æŒ‡é’ˆï¼Œåœ¨x264_pixel_initä¸­è¿›è¡Œåˆå§‹åŒ–ï¼Œè¿™é‡Œç›´æ¥çœ‹Cå®ç°çš„å®å®šä¹‰å±•å¼€

```c++
#define PIXEL_SSD_C( name, lx, ly ) \
static int name( pixel *pix1, intptr_t i_stride_pix1,  \
                 pixel *pix2, intptr_t i_stride_pix2 ) \
{                                                   \
    int i_sum = 0;                                  \
    for( int y = 0; y < ly; y++ )                   \
    {                                               \
        for( int x = 0; x < lx; x++ )               \
        {                                           \
            int d = pix1[x] - pix2[x];              \
            i_sum += d*d;                           \
        }                                           \
        pix1 += i_stride_pix1;                      \
        pix2 += i_stride_pix2;                      \
    }                                               \
    return i_sum;                                   \
}
```



**å°ç»“ï¼š**

å½“i_mbrdç­‰äº1çš„æ—¶å€™è¿›è¡Œ*RD mode decision*ï¼Œ å¤§æ¦‚åŸç†å°±æ˜¯å‰é¢é€šè¿‡mb_analyse_intraå·²ç»ç¡®å®šIntraå®å—16x16ã€8x8ã€4x4ä¸‰ç§åˆ’åˆ†ç±»å‹çš„æœ€ä½³é¢„æµ‹æ¨¡å¼ä»¥åŠå¯¹åº”çš„ç¼–ç ä»£ä»·i_satd_i16x16ã€i_satd_i8x8ã€i_satd_i4x4ã€‚å¦‚æœæ²¡æœ‰å¼€å¯RDOçš„è¯ï¼Œä¼šé€‰æ‹©satdæœ€å°çš„å¯¹åº”çš„å®å—ç±»å‹ä»¥åŠé¢„æµ‹æ¨¡å¼ä½œä¸ºå½“å‰å®å—çš„ç¼–ç ç±»å‹å’Œé¢„æµ‹æ¨¡å¼ã€‚

å¦‚æœå¼€å¯*RD mode decision*ï¼Œ ä¼šé‡æ–°è®¡ç®—I_16x16ã€I_8x8ã€I_4x4å¯¹åº”é¢„æµ‹æ¨¡å¼çš„D+Î»*Rä½œä¸ºæ–°çš„ç¼–ç ä»£ä»·i_satd_i16x16ã€i_satd_i8x8ã€i_satd_i4x4ï¼Œå¹¶é€‰æ‹©ä»£ä»·æœ€å°çš„ä½œä¸ºå½“å‰å®å—çš„å®å—ç±»å‹

------



#### å½“i_mbrdç­‰äº2æ—¶çš„RDOï¼šRD refinement

```c++
static void intra_rd_refine( x264_t *h, x264_mb_analysis_t *a )
{
    uint64_t i_satd, i_best;
    int plane_count = CHROMA444 ? 3 : 1;
    h->mb.i_skip_intra = 0;

    if( h->mb.i_type == I_16x16 )
    {
        /* 
        	å¦‚æœæ˜¯I_16x16, é‡æ–°éå†è®¡ç®—å¯ç”¨çš„å¸§å†…é¢„æµ‹æ¨¡å¼å¹¶è®¡ç®—ç¼–ç ä»£ä»·(ç‡å¤±çœŸå€¼)
        */
        int old_pred_mode = a->i_predict16x16;
        const int8_t *predict_mode = predict_16x16_mode_available( h->mb.i_neighbour_intra );
        int i_thresh = a->b_early_terminate ? a->i_satd_i16x16_dir[old_pred_mode] * 9/8 : COST_MAX;
        i_best = a->i_satd_i16x16;
        for( ; *predict_mode >= 0; predict_mode++ )
        {
            int i_mode = *predict_mode;
            if( i_mode == old_pred_mode || a->i_satd_i16x16_dir[i_mode] > i_thresh )
                continue;
            h->mb.i_intra16x16_pred_mode = i_mode;
            i_satd = rd_cost_mb( h, a->i_lambda2 );
            COPY2_IF_LT( i_best, i_satd, a->i_predict16x16, i_mode );
        }
    }

    /* RD selection for chroma prediction */
    // è‰²åº¦å—é¢„æµ‹æ¨¡å¼çš„â€œæ‹©ä¼˜â€
    if( CHROMA_FORMAT == CHROMA_420 || CHROMA_FORMAT == CHROMA_422 )
    {
        const int8_t *predict_mode = predict_chroma_mode_available( h->mb.i_neighbour_intra );
        if( predict_mode[1] >= 0 )
        {
            int8_t predict_mode_sorted[4];
            int i_max;
            int i_thresh = a->b_early_terminate ? a->i_satd_chroma * 5/4 : COST_MAX;

            for( i_max = 0; *predict_mode >= 0; predict_mode++ )
            {
                int i_mode = *predict_mode;
                if( a->i_satd_chroma_dir[i_mode] < i_thresh && i_mode != a->i_predict8x8chroma )
                    predict_mode_sorted[i_max++] = i_mode;
            }

            if( i_max > 0 )
            {
                int i_cbp_chroma_best = h->mb.i_cbp_chroma;
                int i_chroma_lambda = x264_lambda2_tab[h->mb.i_chroma_qp];
                /* the previous thing encoded was intra_rd(), so the pixels and
                 * coefs for the current chroma mode are still around, so we only
                 * have to recount the bits. */
                i_best = rd_cost_chroma( h, i_chroma_lambda, a->i_predict8x8chroma, 0 );
                for( int i = 0; i < i_max; i++ )
                {
                    int i_mode = predict_mode_sorted[i];
                    if( h->mb.b_lossless )
                        x264_predict_lossless_chroma( h, i_mode );
                    else
                    {
                        h->predict_chroma[i_mode]( h->mb.pic.p_fdec[1] );
                        h->predict_chroma[i_mode]( h->mb.pic.p_fdec[2] );
                    }
                    /* if we've already found a mode that needs no residual, then
                     * probably any mode with a residual will be worse.
                     * so avoid dct on the remaining modes to improve speed. */
                    i_satd = rd_cost_chroma( h, i_chroma_lambda, i_mode, h->mb.i_cbp_chroma != 0x00 );
                    COPY3_IF_LT( i_best, i_satd, a->i_predict8x8chroma, i_mode, i_cbp_chroma_best, h->mb.i_cbp_chroma );
                }
                h->mb.i_chroma_pred_mode = a->i_predict8x8chroma;
                h->mb.i_cbp_chroma = i_cbp_chroma_best;
            }
        }
    }

    if( h->mb.i_type == I_4x4 )
    {
        /* åŒç†ï¼Œé‡æ–°éå†è®¡ç®—i_4x4å¯ç”¨é¢„æµ‹æ¨¡å—çš„ç¼–ç ä»£ä»· */
        pixel4 pels[3][4] = {{0}}; // doesn't need initting, just shuts up a gcc warning
        int nnz[3] = {0};
        for( int idx = 0; idx < 16; idx++ )
        {
            pixel *dst[3] = {h->mb.pic.p_fdec[0] + block_idx_xy_fdec[idx],
                             h->mb.pic.p_fdec[1] + block_idx_xy_fdec[idx],
                             h->mb.pic.p_fdec[2] + block_idx_xy_fdec[idx]};
            i_best = COST_MAX64;

            const int8_t *predict_mode = predict_4x4_mode_available( a->b_avoid_topright, h->mb.i_neighbour4[idx], idx );

            if( (h->mb.i_neighbour4[idx] & (MB_TOPRIGHT|MB_TOP)) == MB_TOP )
                for( int p = 0; p < plane_count; p++ )
                    /* emulate missing topright samples */
                    MPIXEL_X4( dst[p]+4-FDEC_STRIDE ) = PIXEL_SPLAT_X4( dst[p][3-FDEC_STRIDE] );

            for( ; *predict_mode >= 0; predict_mode++ )
            {
                int i_mode = *predict_mode;
                i_satd = rd_cost_i4x4( h, a->i_lambda2, idx, i_mode );

                if( i_best > i_satd )
                {
                    a->i_predict4x4[idx] = i_mode;
                    i_best = i_satd;
                    for( int p = 0; p < plane_count; p++ )
                    {
                        pels[p][0] = MPIXEL_X4( dst[p]+0*FDEC_STRIDE );
                        pels[p][1] = MPIXEL_X4( dst[p]+1*FDEC_STRIDE );
                        pels[p][2] = MPIXEL_X4( dst[p]+2*FDEC_STRIDE );
                        pels[p][3] = MPIXEL_X4( dst[p]+3*FDEC_STRIDE );
                        nnz[p] = h->mb.cache.non_zero_count[x264_scan8[idx+p*16]];
                    }
                }
            }

            for( int p = 0; p < plane_count; p++ )
            {
                MPIXEL_X4( dst[p]+0*FDEC_STRIDE ) = pels[p][0];
                MPIXEL_X4( dst[p]+1*FDEC_STRIDE ) = pels[p][1];
                MPIXEL_X4( dst[p]+2*FDEC_STRIDE ) = pels[p][2];
                MPIXEL_X4( dst[p]+3*FDEC_STRIDE ) = pels[p][3];
                h->mb.cache.non_zero_count[x264_scan8[idx+p*16]] = nnz[p];
            }

            h->mb.cache.intra4x4_pred_mode[x264_scan8[idx]] = a->i_predict4x4[idx];
        }
    }
    else if( h->mb.i_type == I_8x8 )
    {
        /* åŒç†ï¼Œé‡æ–°éå†è®¡ç®—i_8x8å¯ç”¨é¢„æµ‹æ¨¡å—çš„ç¼–ç ä»£ä»· */
        ALIGNED_ARRAY_32( pixel, edge,[4],[32] ); // really [3][36], but they can overlap
        pixel4 pels_h[3][2] = {{0}};
        pixel pels_v[3][7] = {{0}};
        uint16_t nnz[3][2] = {{0}}; //shut up gcc
        for( int idx = 0; idx < 4; idx++ )
        {
            int x = idx&1;
            int y = idx>>1;
            int s8 = X264_SCAN8_0 + 2*x + 16*y;
            pixel *dst[3] = {h->mb.pic.p_fdec[0] + 8*x + 8*y*FDEC_STRIDE,
                             h->mb.pic.p_fdec[1] + 8*x + 8*y*FDEC_STRIDE,
                             h->mb.pic.p_fdec[2] + 8*x + 8*y*FDEC_STRIDE};
            int cbp_luma_new = 0;
            int i_thresh = a->b_early_terminate ? a->i_satd_i8x8_dir[idx][a->i_predict8x8[idx]] * 11/8 : COST_MAX;

            i_best = COST_MAX64;

            const int8_t *predict_mode = predict_8x8_mode_available( a->b_avoid_topright, h->mb.i_neighbour8[idx], idx );
            for( int p = 0; p < plane_count; p++ )
                h->predict_8x8_filter( dst[p], edge[p], h->mb.i_neighbour8[idx], ALL_NEIGHBORS );

            for( ; *predict_mode >= 0; predict_mode++ )
            {
                int i_mode = *predict_mode;
                if( a->i_satd_i8x8_dir[idx][i_mode] > i_thresh )
                    continue;

                h->mb.i_cbp_luma = a->i_cbp_i8x8_luma;
                i_satd = rd_cost_i8x8( h, a->i_lambda2, idx, i_mode, edge );

                if( i_best > i_satd )
                {
                    a->i_predict8x8[idx] = i_mode;
                    cbp_luma_new = h->mb.i_cbp_luma;
                    i_best = i_satd;

                    for( int p = 0; p < plane_count; p++ )
                    {
                        pels_h[p][0] = MPIXEL_X4( dst[p]+7*FDEC_STRIDE+0 );
                        pels_h[p][1] = MPIXEL_X4( dst[p]+7*FDEC_STRIDE+4 );
                        if( !(idx&1) )
                            for( int j = 0; j < 7; j++ )
                                pels_v[p][j] = dst[p][7+j*FDEC_STRIDE];
                        nnz[p][0] = M16( &h->mb.cache.non_zero_count[s8 + 0*8 + p*16] );
                        nnz[p][1] = M16( &h->mb.cache.non_zero_count[s8 + 1*8 + p*16] );
                    }
                }
            }
            a->i_cbp_i8x8_luma = cbp_luma_new;
            for( int p = 0; p < plane_count; p++ )
            {
                MPIXEL_X4( dst[p]+7*FDEC_STRIDE+0 ) = pels_h[p][0];
                MPIXEL_X4( dst[p]+7*FDEC_STRIDE+4 ) = pels_h[p][1];
                if( !(idx&1) )
                    for( int j = 0; j < 7; j++ )
                        dst[p][7+j*FDEC_STRIDE] = pels_v[p][j];
                M16( &h->mb.cache.non_zero_count[s8 + 0*8 + p*16] ) = nnz[p][0];
                M16( &h->mb.cache.non_zero_count[s8 + 1*8 + p*16] ) = nnz[p][1];
            }

            x264_macroblock_cache_intra8x8_pred( h, 2*x, 2*y, a->i_predict8x8[idx] );
        }
    }
}
```



**å°ç»“ï¼š**

å½“i_mbrdç­‰äº2æ—¶ä¼šè¿›è¡Œ*RD refinement*ï¼Œ å…¶åŸç†å°±æ˜¯é‡æ–°å¯¹å·²ç»ç¡®å®šçš„å®å—ç±»å‹i_16x16 or i_8x8 or i_4x4dçš„åŸºç¡€ä¸Šï¼Œé‡æ–°éå†è®¡ç®—å½“å‰å®å—å¯ç”¨çš„é¢„æµ‹æ¨¡å¼çš„ç¼–ç ä»£ä»·(å³D + Î»*R)ï¼Œé€‰æ‹©ç¼–ç ä»£ä»·æœ€å°çš„ä¸€ä¸ªä½œä¸ºå½“å‰å®å—çš„é¢„æµ‹æ¨¡å¼

------



#### å½“i_mbrdç­‰äº3æ—¶çš„RDOï¼šQPRD

```c++
/* Rate-distortion optimal QP selection.
 * FIXME: More than half of the benefit of this function seems to be
 * in the way it improves the coding of chroma DC (by decimating or
 * finding a better way to code a single DC coefficient.)
 * There must be a more efficient way to get that portion of the benefit
 * without doing full QP-RD, but RD-decimation doesn't seem to do the
 * trick. */
static inline void mb_analyse_qp_rd( x264_t *h, x264_mb_analysis_t *a )
{
    int bcost, cost, failures, prevcost, origcost;
    int orig_qp = h->mb.i_qp, bqp = h->mb.i_qp;
    int last_qp_tried = 0;
    origcost = bcost = rd_cost_mb( h, a->i_lambda2 );
    int origcbp = h->mb.cbp[h->mb.i_mb_xy];  // å½“å‰å®å—çš„CBP

    /* If CBP is already zero, don't raise the quantizer any higher. */
    // å¦‚æœå½“å‰å®å—çš„CBPå·²ç»ä¸º0äº†ï¼Œä¸åœ¨å¢å¤§å½“å‰å®å—çš„QPäº†ï¼Œå› ä¸ºå†å¢å¤§äº†å¾—åˆ°çš„CBPä¹Ÿä¸º0ï¼Œæ²¡å¿…è¦
    for( int direction = origcbp ? 1 : -1; direction >= -1; direction-=2 )
    {
        /* Without psy-RD, require monotonicity when moving quant away from previous
         * macroblock's quant; allow 1 failure when moving quant towards previous quant.
         * With psy-RD, allow 1 failure when moving quant away from previous quant,
         * allow 2 failures when moving quant towards previous quant.
         * Psy-RD generally seems to result in more chaotic RD score-vs-quantizer curves. */
        int threshold = (!!h->mb.i_psy_rd);
        /* Raise the threshold for failures if we're moving towards the last QP. */
        if( ( h->mb.i_last_qp < orig_qp && direction == -1 ) ||
            ( h->mb.i_last_qp > orig_qp && direction ==  1 ) )
            threshold++;
        h->mb.i_qp = orig_qp;
        failures = 0;
        prevcost = origcost;

        /* If the current QP results in an empty CBP, it's highly likely that lower QPs
         * (up to a point) will too.  So, jump down to where the threshold will kick in
         * and check the QP there.  If the CBP is still empty, skip the main loop.
         * If it isn't empty, we would have ended up having to check this QP anyways,
         * so as long as we store it for later lookup, we lose nothing. */
        /* å¦‚æœå½“å‰å®å—çš„CBPå·²ç»ä¸º0äº†ï¼Œé‚£ä¹ˆå¯ä»¥å°è¯•å†é™ä½QPçœ‹CBPæ˜¯å¦è¿˜ä¼šä¸º0ï¼Œå¦‚æœè¿˜æ˜¯0å°±å¯ä»¥ç›´æ¥breakäº† */
        int already_checked_qp = -1;
        int already_checked_cost = COST_MAX;
        if( direction == -1 )
        {
            if( !origcbp ) // å¦‚æœå½“å‰CBPä¸º0
            {
                // é™ä½å½“å‰å®å—çš„QP
                h->mb.i_qp = X264_MAX( h->mb.i_qp - threshold - 1, SPEC_QP( h->param.rc.i_qp_min ) );
                h->mb.i_chroma_qp = h->chroma_qp_table[h->mb.i_qp];
                already_checked_cost = rd_cost_mb( h, a->i_lambda2 );
                if( !h->mb.cbp[h->mb.i_mb_xy] )
                {
                    // å¦‚æœé™ä½QPåå®å—çš„CBPè¿˜æ˜¯ä¸º0ï¼Œå°±æ²¡å¤šå¤§å¿…è¦å†å¾€ä¸‹é™äº†ï¼Œç›´æ¥è·³å‡º
                    /* If our empty-CBP block is lower QP than the last QP,
                     * the last QP almost surely doesn't have a CBP either. */
                    // å¦‚æœä¸Šä¸€å®å—çš„QP > å½“å‰å®å—QPï¼Œé‚£ä¹ˆbreakå®Œä¹‹åä¹Ÿä¸éœ€è¦å†è¿›è¡Œâ€œç”¨ä¸Šä¸€å®å—çš„QPç¼–ç å½“å‰å®å—â€çš„å®éªŒæµ‹è¯•
                    if( h->mb.i_last_qp > h->mb.i_qp )
                        last_qp_tried = 1;
                    break;
                }
                already_checked_qp = h->mb.i_qp;
                h->mb.i_qp = orig_qp;
            }
        }
		
        /* å¢å¤§/å‡å°‘å½“å‰å®å—QPçœ‹çœ‹æ”¶ç›Šä¼šä¸ä¼šæ›´é«˜ */
        h->mb.i_qp += direction;
        while( h->mb.i_qp >= h->param.rc.i_qp_min && h->mb.i_qp <= SPEC_QP( h->param.rc.i_qp_max ) )
        {
            if( h->mb.i_last_qp == h->mb.i_qp )
                last_qp_tried = 1; // æ ‡è¯†å·²ç»å°è¯•è¿‡â€œç”¨ä¸Šä¸€å®å—â€è¿›è¡Œç¼–ç äº†
            if( h->mb.i_qp == already_checked_qp )  
                cost = already_checked_cost; // costå·²ç»è®¡ç®—è¿‡å°±ä¸é‡å¤è®¡ç®—äº†ï¼Œç›´æ¥èµ‹å€¼
            else
            {
                h->mb.i_chroma_qp = h->chroma_qp_table[h->mb.i_qp];
                cost = rd_cost_mb( h, a->i_lambda2 );
                COPY2_IF_LT( bcost, cost, bqp, h->mb.i_qp );
            }

            /* We can't assume that the costs are monotonic over QPs.
             * Tie case-as-failure seems to give better results. */
            /* æ¯”è¾ƒQPè°ƒæ•´åçš„ç¼–ç ä»£ä»·ï¼Œå¦‚æœcost>=prevcostè¯´æ˜QPè°ƒæ•´åæ²¡æœ‰ä¼˜åŒ–æ•ˆæœ */
            if( cost < prevcost )
                failures = 0;
            else
                failures++;
            prevcost = cost;

            if( failures > threshold )
                break;
            if( direction == 1 && !h->mb.cbp[h->mb.i_mb_xy] )
                break;
            h->mb.i_qp += direction;
        }
    }

    /* Always try the last block's QP. */
    // ç”¨ä¸Šä¸€ä¸ªå®å—çš„QPå†è¯•ä¸€ä¸‹ï¼Œçœ‹çœ‹æ•ˆæœ
    if( !last_qp_tried )
    {
        h->mb.i_qp = h->mb.i_last_qp;
        h->mb.i_chroma_qp = h->chroma_qp_table[h->mb.i_qp];
        cost = rd_cost_mb( h, a->i_lambda2 );
        COPY2_IF_LT( bcost, cost, bqp, h->mb.i_qp );
    }

    h->mb.i_qp = bqp;
    h->mb.i_chroma_qp = h->chroma_qp_table[h->mb.i_qp];

    /* Check transform again; decision from before may no longer be optimal. */
    if( h->mb.i_qp != orig_qp && h->param.analyse.b_transform_8x8 &&
        x264_mb_transform_8x8_allowed( h ) )
    {
        h->mb.b_transform_8x8 ^= 1;
        cost = rd_cost_mb( h, a->i_lambda2 );
        if( cost > bcost )
            h->mb.b_transform_8x8 ^= 1;
    }
}
```



**å°ç»“ï¼š**

å½“i_mbrdç­‰äº2æ—¶ä¼šè¿›è¡Œ*QPRD*ï¼Œ é¡¾åæ€ä¹‰å°±æ˜¯QPè¿›è¡Œç‡å¤±çœŸä¼˜åŒ–ã€‚åŸç†å¤§è‡´æ˜¯ï¼šå¦‚æœå½“å‰å®å—çš„CBPä¸º0ï¼Œ é‚£ä¹ˆå°è¯•é™ä½QPè¿›è¡Œç¼–ç çœ‹çœ‹æ˜¯å¦æœ‰æ”¶ç›Šï¼›å¦‚æœCBPä¸ä¸º0ï¼Œé‚£ä¹ˆä¹Ÿä¼šè°ƒæ•´QPè¿›è¡Œç¼–ç ä»£ä»·çš„å¯¹æ¯”ï¼Œæ‹©ä¼˜é€‰æ‹©ã€‚



### å‚è€ƒå¼•ç”¨

ğŸ±â€ğŸhttps://github.com/mirror/x264
